<!DOCTYPE html>
<html>
<head>
	<title>IFC - GLSL Shader Feedback Test</title>
	<meta charset="UTF-8"/>

	<link rel="stylesheet" href="/css/style.css">
	<style type="text/css">
		#stats { position: absolute; top:0; left: 0 }
		#stats #fps { background: transparent !important }
		#stats #fps #fpsText { color: #aaa !important }
		#stats #fps #fpsGraph { display: block }
	</style>

	<!--load helper libraries-->
	<script type="text/javascript" src="/js/lib/jquery-2.0.2.min.js"></script>

	<!--load AR and 3D libraries-->
	<script type="text/javascript" src="/js/lib/three.min.js"></script>
	<script type="text/javascript" src="/js/lib/Detector.js"></script>
	<script type="text/javascript" src="/js/lib/stats.min.js"></script>
	<script type="text/javascript" src="/js/lib/dat.gui.min.js"></script>
	<script type="text/javascript" src="/js/lib/OrbitControls.js"></script>

	<script type="text/javascript" src="/js/ShaderManager.js"></script>

	<script>

	var PLANE_SIZE = 10;
	var PLANE_RES = 256;
	var PLANE_GRID_SIZE = PLANE_SIZE / PLANE_RES;
	var SHADOW_MAP_RES = 1024;

	var clock = new THREE.Clock();

	function checkWebGl()
	{
		//check for WebGL
		if (!Detector.webgl)
		{
			$('div').remove();
			Detector.addGetWebGLMessage();
			throw new Error('Your browser does not seem to support WebGL');
		}
	}

	function setupShaders()
	{
	    THREE.ShaderManager.addShader('/glsl/passUv.vert');
		THREE.ShaderManager.addShader('/glsl/hfWater_muellerGdc2008Hw.frag');
		THREE.ShaderManager.addShader('/glsl/heightMap.vert');
		THREE.ShaderManager.addShader('/glsl/lambert.frag');
	}

	var renderer, scene, camera, controls;
	var materials = [];
	var localAxis;
	var planeGeom, planeMaterial, planeMesh;
	var groundGeom, groundMaterial, groundMesh;
	var visGeom, visMaterial, visMesh;
	var lightGeom, lightMaterial, lightMesh;
	function setupThreejsScene()
	{
		//create renderer
		renderer = new THREE.WebGLRenderer({
			antialias : true
		});
		renderer.setSize(window.innerWidth, window.innerHeight-5);
		renderer.setClearColor('#111111', 1);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapType = THREE.PCFSoftShadowMap;
		renderer.shadowMapSoft = true;
		checkExtensions(renderer);
		var $container = $('#threejs-container');
		$container.append(renderer.domElement);

		//create scene
		scene = new THREE.Scene();

		//create camera
		camera = new THREE.PerspectiveCamera(25, renderer.domElement.width/renderer.domElement.height, 0.1, 1000);
		camera.position.set(8, 8, 15);
		camera.lookAt(new THREE.Vector3(0,0,0));

		//create controls for camera
		controls = new THREE.OrbitControls(camera);
		controls.userPanSpeed = 0.2;
		//controls.autoRotate = true;
		controls.modifierKey = 'alt';

		//create axis
		localAxis = new THREE.AxisHelper();
		scene.add(localAxis);

		//setup lights
		//TODO: use these lights
		scene.add(new THREE.AmbientLight(0x111111));

		keyLight = new THREE.SpotLight(0xffff44, 0.6);
		keyLight.position.set(5, 15, -15);
		keyLight.target.position.set(0, 0, 0);
		keyLight.castShadow = true;
		keyLight.shadowCameraNear = 10;
		keyLight.shadowCameraFar = 30;
		keyLight.shadowCameraFov = 30;
		//keyLight.shadowCameraVisible = true;
		keyLight.shadowBias = 0.00001;
		keyLight.shadowDarkness = 0.4;
		keyLight.shadowMapWidth = SHADOW_MAP_RES;
		keyLight.shadowMapHeight = SHADOW_MAP_RES;
		scene.add(keyLight);

		fillLight = new THREE.SpotLight(0xff0044, 0.4);
		fillLight.position.set(5, 2, 15);
		fillLight.target.position.set(0, 0, 0);
		scene.add(fillLight);

		//create a plane for the actual height displacement
		planeGeom = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, PLANE_RES - 1, PLANE_RES - 1);
		planeGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
	    planeMaterial = new THREE.ShaderMaterial({
		    uniforms: {
		        uTexture: { type: 't', value: rttRenderTarget1 },
		        uTexelSize: { type: 'v2', value: new THREE.Vector2(1.0 / PLANE_RES, 1.0 / PLANE_RES) },
		        uTexelWorldSize: { type: 'v2', value: new THREE.Vector2(PLANE_GRID_SIZE, PLANE_GRID_SIZE) },
		        uHeightMultiplier: { type: 'f', value: 1.0 },
		        uBaseColor: { type: 'v3', value: new THREE.Vector3(0.2, 1, 1) },
		        uAmbientLightColor: { type: 'v3', value: new THREE.Vector3(1, 1, 1) },
		        uAmbientLightIntensity: { type: 'f', value: 0.1 },
		        uPointLight1WorldPos: { type: 'v3', value: new THREE.Vector3(2, 2, 2) },
		        uPointLight1Color: { type: 'v3', value: new THREE.Vector3(1, 0, 0) },
		        uPointLight1Intensity: { type: 'f', value: 3.0 },
		        uPointLight1FalloffStart: { type: 'f', value: 1.0 },
		        uPointLight1FalloffEnd: { type: 'f', value: 10.0 }
		    },
		    vertexShader: THREE.ShaderManager.getShaderContents('/glsl/heightMap.vert'),
		    fragmentShader: THREE.ShaderManager.getShaderContents('/glsl/lambert.frag')
		});
		materials.push(planeMaterial);
		planeMesh = new THREE.Mesh(planeGeom, planeMaterial);
		planeMesh.castShadow = true;
		planeMesh.receiveShadow = true;
		scene.add(planeMesh);

		//create plane for intersection test
		groundPlaneGeom = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, 1, 1);
		groundPlaneGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		// groundPlaneGeom.applyMatrix(new THREE.Matrix4().makeTranslation(0, MEAN_WATER_HEIGHT, 0));  //move groundPlaneGeom up by MEAN_WATER_HEIGHT to detect correct intersection later
		var groundPlaneMaterial = new THREE.MeshPhongMaterial();
		materials.push(groundPlaneMaterial);
		groundPlaneMesh = new THREE.Mesh(groundPlaneGeom, groundPlaneMaterial);
		groundPlaneMesh.castShadow = false;
		groundPlaneMesh.receiveShadow = false;
		groundPlaneMesh.visible = false;
		scene.add(groundPlaneMesh);

		//create a RTT visualization plane
		visGeom = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, 1, 1);
		visGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
	    visMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, map: rttRenderTarget1 } );
		materials.push(visMaterial);
		visMesh = new THREE.Mesh(visGeom, visMaterial);
		visMesh.position.y = 3;
		visMesh.castShadow = true;
		visMesh.receiveShadow = true;
		scene.add(visMesh);

		//create a sphere that represents the point light
		lightGeom = new THREE.SphereGeometry(0.1, 8, 8);
		lightMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
		materials.push(lightMaterial);
		lightMesh = new THREE.Mesh(lightGeom, lightMaterial);
		scene.add(lightMesh);
	}

	function checkExtensions(renderer)
	{
	    var context = renderer.context;
        if (!context.getExtension('OES_texture_float_linear')) {
            throw new Error('Extension not available: OES_texture_float_linear');
        }
        if (!context.getParameter(context.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) {
            throw new Error('Vertex textures not supported on your graphics card');
        }
	}

	var rttScene, rttCamera, rttRenderTarget1, rttRenderTarget2;
	var rttQuadGeom, rttQuadMaterial, rttQuadMesh;
	function setupRttScene()
	{
	    //create a RTT scene
	    rttScene = new THREE.Scene();

	    //create an orthographic RTT camera
	    var halfSize = PLANE_SIZE / 2.0;
	    var far = 10000;
	    var near = -far;
	    rttCamera = new THREE.OrthographicCamera(-halfSize, halfSize, halfSize, -halfSize, near, far);

	    //create a quad which we will use to invoke the shaders
	    rttQuadGeom = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE);
	    rttQuadMaterial = new THREE.ShaderMaterial({
	        uniforms: {
	            uTexture: { type: 't', value: null },
	            uTexelSize: { type: 'v2', value: new THREE.Vector2(1.0 / PLANE_RES, 1.0 / PLANE_RES) },
		        uTexelWorldSize: { type: 'v2', value: new THREE.Vector2(PLANE_SIZE / PLANE_RES, PLANE_SIZE / PLANE_RES) },
		        uIsDisturbing: { type: 'i', value: 0 },
		        uDisturbPos: { type: 'v2', value: new THREE.Vector2(0.5, 0.5) },
		        uDisturbAmount: { type: 'f', value: 0.05 },
		        uDisturbRadius: { type: 'f', value: 0.0025 * PLANE_SIZE },
		        uDampingFactor: { type: 'f', value: 0.95 }
	        },
	        vertexShader: THREE.ShaderManager.getShaderContents('/glsl/passUv.vert'),
	        fragmentShader: THREE.ShaderManager.getShaderContents('/glsl/hfWater_muellerGdc2008Hw.frag')
	    });
	    rttQuadMesh = new THREE.Mesh(rttQuadGeom, rttQuadMaterial);
	    rttScene.add(rttQuadMesh);

	    //create RTT render targets (we need two to do feedback)
	    var linearFloatParams = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            format: THREE.RGBFormat,
            stencilBuffer: false,
            depthBuffer: false,
            type: THREE.FloatType
        };
	    rttRenderTarget1 = new THREE.WebGLRenderTarget(PLANE_RES, PLANE_RES, linearFloatParams);
	    rttRenderTarget1.generateMipmaps = false;
	    rttRenderTarget2 = rttRenderTarget1.clone();
	}

	function swapRenderTargets()
	{
	    var temp = rttRenderTarget1;
	    rttRenderTarget1 = rttRenderTarget2;
	    rttRenderTarget2 = temp;
	    rttQuadMaterial.uniforms['uTexture'].value = rttRenderTarget2;
	}

	function setupEvents()
	{
		window.addEventListener('resize', window_onResize, false);
		window.addEventListener('keydown', window_onKeyDown, false);
		window.addEventListener('keyup', window_onKeyUp, false);
		window.addEventListener('mousedown', window_onMouseDown, false);
		window.addEventListener('mousemove', window_onMouseMove, false);
		window.addEventListener('mouseup', window_onMouseUp, false);
	}

	function window_onResize(event)
	{
		//update camera projection
		camera.aspect = window.innerWidth / (window.innerHeight-5);
		camera.updateProjectionMatrix();

		//update renderer size
		renderer.setSize(window.innerWidth, window.innerHeight-5);
	}

	var activateDisturb = false;
	function window_onKeyDown(event)
	{
		if (event.keyCode === 32)  //space
		{
			activateDisturb = true;
		}
	}

	function window_onKeyUp(event)
	{
		if (event.keyCode === 32)  //space
		{
			activateDisturb = false;
		}
	}

	var isDisturbing = false;
	var disturbUvPos = new THREE.Vector2();
	function window_onMouseDown(event)
	{
	    if (activateDisturb) {
            if (event.button === 0)  //LMB
            {
                isDisturbing = true;

                //detect intersection
                intersectPoint = detectIntersection();
                if (intersectPoint)
                {
                    disturbUvPos.x = (intersectPoint.x + PLANE_SIZE / 2.0) / PLANE_SIZE;
                    disturbUvPos.y = (intersectPoint.z + PLANE_SIZE / 2.0) / PLANE_SIZE;
                }
            }
        }
	}

	function window_onMouseMove(event)
	{
		event.preventDefault();

		if (activateDisturb && isDisturbing) {
            if (event.button === 0)  //LMB
            {
                //detect intersection
                intersectPoint = detectIntersection();
                if (intersectPoint)
                {
                    disturbUvPos.x = (intersectPoint.x + PLANE_SIZE / 2.0) / PLANE_SIZE;
                    disturbUvPos.y = (intersectPoint.z + PLANE_SIZE / 2.0) / PLANE_SIZE;
                }
            }
        }
	}

	function window_onMouseUp(event)
	{
	    isDisturbing = false;
	}

	var intersectPoint = new THREE.Vector3();
	var mousePosNorm = new THREE.Vector2();
	var projector = new THREE.Projector();
	var raycaster = new THREE.Raycaster();
	function detectIntersection()
	{
		mousePosNorm.x = (event.clientX / window.innerWidth) * 2 - 1;
		mousePosNorm.y = - (event.clientY / window.innerHeight) * 2 + 1;

		//cast a ray from camera into screen
		var worldPos = new THREE.Vector3(mousePosNorm.x, mousePosNorm.y, 1);
		projector.unprojectVector(worldPos, camera);
		raycaster.set(camera.position, worldPos.sub(camera.position).normalize());
		var intersectInfo = raycaster.intersectObject(groundPlaneMesh);

		//get intersection point and vertexId
		if (intersectInfo && intersectInfo[0])
		{
			return intersectInfo[0].point;
		}
	}

	var stats;
	function setupStats()
	{
		//create a stats monitor
		stats = new Stats();
		$('body').append(stats.domElement);
	}

	var gui;
	var renderingFolder, displayFolder;
	var options = {
		renderingShadows: true,  //FIXME: this has to be init to true
		displayWireframe: false,
		displayLocalAxis: false,
	};
	function setupGui() {

		gui = new dat.GUI();
		//gui.close();  //close GUI by default

		//Rendering folder
		renderingFolder = gui.addFolder('Rendering');

		var control = renderingFolder.add(options, 'renderingShadows').name('Shadows');
		function changeRenderingShadows(value)
		{
			renderer.shadowMapAutoUpdate = value;
			if (!value)
			{
				renderer.clearTarget(keyLight.shadowMap);
			}
		}
		control.onChange(changeRenderingShadows);
		changeRenderingShadows(options.renderingShadows);

		//Display folder
		displayFolder = gui.addFolder('Display');

		control = displayFolder.add(options, 'displayWireframe').name('Wireframe');
		function toggleWireframe(value)
		{
			for (materialId in materials)
			{
				materials[materialId].wireframe = value;
			}
		}
		control.onChange(toggleWireframe);
		toggleWireframe(options.displayWireframe);

		control = displayFolder.add(options, 'displayLocalAxis').name('Local Axis');
		function toggleLocalAxis(value)
		{
			localAxis.visible = value;
		}
		control.onChange(toggleLocalAxis);
		toggleLocalAxis(options.displayLocalAxis);
	}

	$(document).ready(function()
	{
		//check for WebGL
		checkWebGl();

		console.log('Document is ready.');

		//get shader contents
		setupShaders();

		//setup RTT scene
		setupRttScene();

		//setup scene
		setupThreejsScene();

		//setup events
		setupEvents();

		//setup stats monitor
		setupStats();

		//setup GUI
		setupGui();

		//main loop
		function loop()
		{
			var dt = clock.getDelta();  //have to call this before getElapsedTime()
			var time = clock.getElapsedTime();

			//update RTT uniforms
			rttQuadMaterial.uniforms['uIsDisturbing'].value = isDisturbing;
			rttQuadMaterial.uniforms['uDisturbPos'].value.copy(disturbUvPos);

			//update light uniforms
			planeMaterial.uniforms['uPointLight1WorldPos'].value.x = 3 * Math.sin(time);
			planeMaterial.uniforms['uPointLight1WorldPos'].value.z = 3 * Math.cos(time);
			lightMesh.position.copy(planeMaterial.uniforms['uPointLight1WorldPos'].value);

			controls.update();

			renderer.autoClear = false;
			renderer.clear();
			renderer.render(rttScene, rttCamera, rttRenderTarget1, false);
			swapRenderTargets();

			renderer.render(scene, camera);

			stats.update();

			requestAnimationFrame(loop);
		}
		loop();

	});
	</script>
</head>
<body>
	<div id="threejs-container"></div>
	<div class="translucent" id="info-container">
		<div>Camera: [ Alt+LMB: rotate ] [ Alt+MMB: pan ] [ Alt+RMB: zoom ]</div>
		<div>Water: [ Spc+LMB: disturb ] [ Spc+RMB: source ] [ Spc+MMB: sink ]</div>
	</div>
</body>
</html>