<!DOCTYPE html>
<html>
<head>
	<title>IFC - Terrain</title>
	<meta charset="UTF-8"/>
	
	<link rel="stylesheet" href="/css/style.css">
	<style type="text/css">
		#stats { position: absolute; top:0; left: 0 }
		#stats #fps { background: transparent !important }
		#stats #fps #fpsText { color: #aaa !important }
		#stats #fps #fpsGraph { display: block }
	</style>
	
	<!--load helper libraries-->
	<script type="text/javascript" src="/js/lib/jquery-2.0.2.min.js"></script>
	
	<!--load AR and 3D libraries-->
	<script type="text/javascript" src="/js/lib/three.min.js"></script>
	<script type="text/javascript" src="/js/lib/Detector.js"></script>
	<script type="text/javascript" src="/js/lib/stats.min.js"></script>
	<script type="text/javascript" src="/js/lib/dat.gui.min.js"></script>
	<script type="text/javascript" src="/js/lib/OrbitControls.js"></script>

	<script type="text/javascript" src="/js/lib/SimplexNoise.js"></script>	
	<script type="text/javascript" src="/js/lib/StackBlur.js"></script>	
	
	<script>
	
	var renderer, scene, camera;
	var keyLight, fillLight;
	var localAxis;
	var terrainGeom;
	var materials = [];
	var torusKnotMesh, boxMesh, sphereMesh;
	var clock = new THREE.Clock();
	var simplex = new SimplexNoise();
	var shadowMapRes = 1024;
	var terrainRes = 256;
	var options = {
			terrainPreBlur: 2.0,
			terrainHeight: 0.2,
			renderingShadows: true,
			displayWireframe: false,
			displayLocalAxis: false,
		};

	var terrainImage = '/resources/images/igms_617851,4595749,620411,4598309_512.jpg';
	var useTerrainImage = true;
	var terrainImageData;
	var $imageCanvasElem, imageCanvasElemContext;
	var $scaledImageObj;

	function checkWebGl()
	{
		//check for WebGL
		if (!Detector.webgl)
		{
			$('div').remove();
			Detector.addGetWebGLMessage();
			throw new Error('Your browser does not seem to support WebGL');
		}
	}

	function filterTerrainImageAndGenerateHeight()
	{
		//draw image onto canvas
		//NO NEED TO DO THIS WHEN USING stackBlurImage()
        //imageCanvasElemContext.drawImage($scaledImageObj, 0, 0, terrainImageWidth, terrainImageHeight);

        //do pre-blur filtering first
        stackBlurImage('scaledTerrainImage', 'terrainImageCanvas', options.terrainPreBlur, false);

        //get filtered image data
        terrainImageData = imageCanvasElemContext.getImageData(0, 0, terrainRes, terrainRes).data;

		generateTerrainHeight(terrainGeom);
	}

	function loadTerrainImage()
	{
		//create canvas that is same size as terrain res so that one vertex maps to one resized pixel
		$imageCanvasElem = $(document.createElement('canvas'));
		$imageCanvasElem[0].id = 'terrainImageCanvas';
		$imageCanvasElem[0].width = terrainRes;
		$imageCanvasElem[0].height = terrainRes;
		$imageCanvasElem.css({'display':'none'});
		$('body').append($imageCanvasElem);
		
		//get canvas context
        imageCanvasElemContext = $imageCanvasElem[0].getContext('2d');

		//load terrain image
		$scaledImageObj = $(new Image());
		$scaledImageObj[0].id = 'scaledTerrainImage';
		$scaledImageObj[0].onload = function()
		{
			//this function is triggered from $origImageObj setting this src
			
			//start filtering and changing heights
			filterTerrainImageAndGenerateHeight();
		};
		$scaledImageObj.css({'display':'none'});
		$('body').append($scaledImageObj);

		//load original terrain image, scale it using canvas, then set scaled image to $scaledImageObj
		var $origImageObj = $(new Image());
		$origImageObj[0].onload = function()
		{
			//copy to scaled canvas to scale this image
			imageCanvasElemContext.drawImage($origImageObj[0], 0, 0, terrainRes, terrainRes);

			//get scaled data from canvas and set data for scaledImageObj
			$scaledImageObj[0].src = $imageCanvasElem[0].toDataURL();
		};
		$origImageObj[0].src = terrainImage;
	}

	function generateTerrainHeight(geometry)
	{
		clock.start();

		var minY = 99999;
		if (useTerrainImage)
		{
			//read the image data and use that as height
			//TODO: use shader to make this run parallel on GPU if too slow
			//iterate through vertices (they are ordered)
			for (var i=0; i<geometry.vertices.length; i++)
			{
				var vertex = geometry.vertices[i];
				vertex.y = terrainImageData[i*4] / 255.0 * options.terrainHeight;
				if (vertex.y < minY)
				{
					minY = vertex.y;
				}
			}
		}
		else
		{
			//TODO: use FBm instead
			//TODO: use shader to make this run parallel on GPU if too slow
			for (var i=0; i<geometry.vertices.length; i++)
			{
				var vertex = geometry.vertices[i];
				vertex.y = (simplex.noise(vertex.x, vertex.z) / 2.0 + 0.5) * options.terrainHeight;
				if (vertex.y < minY)
				{
					minY = vertex.y;
				}
			}


		}

		//shift all vertices down so that min point touches y=0
		for (var i=0; i<geometry.vertices.length; i++)
		{
			var vertex = geometry.vertices[i];
			vertex.y -= minY;
		}
		

		//geometry.dynamic = true;
		geometry.computeFaceNormals();  //must call this first before computeVertexNormals()
		geometry.computeVertexNormals();
		//geometry.computeCentroids();
		//geometry.computeBoundingBox();
		//geometry.computeBoundingSphere();

		geometry.verticesNeedUpdate = true;
		geometry.normalsNeedUpdate = true;

		var t = clock.getDelta();
		console.log('Generate height: ' + t.toFixed(3) + ' seconds');
		clock.stop();
	}

	function setupThreejsScene()
	{
		//create renderer
		renderer = new THREE.WebGLRenderer({
			antialias : true
		});
		renderer.setSize(window.innerWidth, window.innerHeight-5);
		renderer.setClearColor('#081419', 1);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapType = THREE.PCFShadowMap;
		renderer.shadowMapSoft = true;
		var $container = $('#threejs-container');
		$container.append(renderer.domElement);

		//create scene
		scene = new THREE.Scene();

		//create camera
		camera = new THREE.PerspectiveCamera(25, renderer.domElement.width/renderer.domElement.height, 0.1, 1000 );
		camera.position.set(8, 8, 15);
		camera.lookAt(new THREE.Vector3(0,0,0));

		//create controls for camera
		controls = new THREE.OrbitControls(camera);
		controls.userPanSpeed = 0.2;
		//controls.autoRotate = true;
		controls.modifierKey = 'alt';

		//create plane
		var groundPlaneGeom = new THREE.PlaneGeometry(10, 10, 1, 1);
		groundPlaneGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		var groundPlaneMaterial = new THREE.MeshPhongMaterial();
		materials.push(groundPlaneMaterial);
		var groundPlaneMesh = new THREE.Mesh(groundPlaneGeom, groundPlaneMaterial);
		groundPlaneMesh.castShadow = true;
		groundPlaneMesh.receiveShadow = true;
		scene.add(groundPlaneMesh);

		//create terrain
		terrainGeom = new THREE.PlaneGeometry(10, 10, terrainRes-1, terrainRes-1);
		terrainGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		var terrainMaterial = new THREE.MeshPhongMaterial();
		materials.push(terrainMaterial);
		var terrainMesh = new THREE.Mesh(terrainGeom, terrainMaterial);
		terrainMesh.castShadow = true;
		terrainMesh.receiveShadow = true;
		scene.add(terrainMesh);

		//change height using noise
		//generateTerrainHeight(terrainGeom);  //called by ui during init

		var torusKnotGeom = new THREE.TorusKnotGeometry(0.35, 0.1, 50, 8);
		var torusKnotMaterial = new THREE.MeshPhongMaterial({color:'#ff4444'});
		torusKnotMaterial.shininess = 50;
		materials.push(torusKnotMaterial);
		torusKnotMesh = new THREE.Mesh(torusKnotGeom, torusKnotMaterial);
		torusKnotMesh.position.x = -2;
		torusKnotMesh.position.y = 1;
		torusKnotMesh.castShadow = true;
		torusKnotMesh.receiveShadow = false;
		scene.add(torusKnotMesh);

		var boxGeom = new THREE.CubeGeometry(1, 1, 1);
		var boxMaterial = new THREE.MeshPhongMaterial({color:'#ff4444'});
		materials.push(boxMaterial);
		boxMesh = new THREE.Mesh(boxGeom, boxMaterial);
		boxMesh.position.y = 1;
		boxMesh.castShadow = true;
		boxMesh.receiveShadow = false;
		scene.add(boxMesh);

		var sphereGeom = new THREE.SphereGeometry(0.65, 10, 10);
		var sphereMaterial = new THREE.MeshPhongMaterial({color:'#ff4444'});
		sphereMaterial.shininess = 50;
		materials.push(sphereMaterial);
		sphereMesh = new THREE.Mesh(sphereGeom, sphereMaterial);
		sphereMesh.position.x = 2;
		sphereMesh.position.y = 1;
		sphereMesh.castShadow = true;
		sphereMesh.receiveShadow = false;
		scene.add(sphereMesh);

		//create axis
		localAxis = new THREE.AxisHelper();
		scene.add(localAxis);

		//setup lights
		scene.add(new THREE.AmbientLight(0x000015));

		keyLight = new THREE.SpotLight(0xffff00, 0.3);
		keyLight.position.set(5, 15, -15);
		keyLight.target.position.set(0, 0, 0);
		keyLight.castShadow = true;
		keyLight.shadowCameraNear = 15;
		keyLight.shadowCameraFar = 30;
		keyLight.shadowCameraFov = 30;
		//keyLight.shadowCameraVisible = true;
		keyLight.shadowBias = 0.0001;
		keyLight.shadowDarkness = 0.5;
		keyLight.shadowMapWidth = shadowMapRes;
		keyLight.shadowMapHeight = shadowMapRes;
		scene.add(keyLight);

		fillLight = new THREE.SpotLight(0x00ff00, 0.2);
		fillLight.position.set(5, 2, 15);
		fillLight.target.position.set(0, 0, 0);
		scene.add(fillLight);
	}

	function setupGui() {

		var gui = new dat.GUI();
		//gui.close();  //close GUI by default

		//Terrain folder
		folder = gui.addFolder('Terrain');
		folder.open();

		var control = folder.add(options, 'terrainPreBlur', 0, 10).name('Pre-Blur');
		function changeTerrainPreBlur(value)
		{
			terrainPreBlur = value;
			filterTerrainImageAndGenerateHeight(value);
		}
		control.onChange(changeTerrainPreBlur);
		//changeTerrainPreBlur(options.terrainPreBlur);

		control = folder.add(options, 'terrainHeight', 0, 2).name('Height');
		function changeTerrainHeight(value)
		{
			terrainHeight = value;
			generateTerrainHeight(terrainGeom);
		}
		control.onChange(changeTerrainHeight);
		//changeTerrainHeight(options.terrainHeight);

		//Rendering folder
		folder = gui.addFolder('Rendering');

		control = folder.add(options, 'renderingShadows', 0, 10).name('Shadows');
		function changeRenderingShadows(value)
		{
			renderer.shadowMapAutoUpdate = value;
			if (!value)
			{
				renderer.clearTarget(keyLight.shadowMap);
			}
		}
		control.onChange(changeRenderingShadows);
		changeRenderingShadows(options.renderingShadows);

		//Display folder
		folder = gui.addFolder('Display');
		
		control = folder.add(options, 'displayWireframe').name('Wireframe');
		function toggleWireframe(value)
		{
			for (materialId in materials)
			{
				materials[materialId].wireframe = value;
			}
		}
		control.onChange(toggleWireframe);
		toggleWireframe(options.displayWireframe);
		
		control = folder.add(options, 'displayLocalAxis').name('Local Axis');
		function toggleLocalAxis(value)
		{
			localAxis.visible = value;
		}
		control.onChange(toggleLocalAxis);
		toggleLocalAxis(options.displayLocalAxis);
	}

	function setupEvents()
	{
		window.addEventListener('resize', window_onResize, false);
	}

	function setupStats()
	{
		//create a stats monitor
		stats = new Stats();
		$('body').append(stats.domElement);
	}

	function window_onResize(event)
	{
		//update camera projection
		camera.aspect = window.innerWidth / (window.innerHeight-5);
		camera.updateProjectionMatrix();

		//update renderer size
		renderer.setSize(window.innerWidth, window.innerHeight-5);
	}

	$(document).ready(function()
	{
		//check for WebGL
		checkWebGl();

		console.log('Document is ready.');

		//load terrain image
		if (useTerrainImage)
		{
			loadTerrainImage();
		}

		//setup scene
		setupThreejsScene();

		//setup events
		setupEvents();

		//setup stats monitor
		setupStats();
		
		//setup GUI
		setupGui();
		
		//main loop
		function loop()
		{
			var time = clock.getElapsedTime();

			torusKnotMesh.position.y = 1.5 + 0.25 * Math.sin(time*3-0.5);
			boxMesh.position.y = 1.5 + 0.25 * Math.sin(time*3);
			sphereMesh.position.y = 1.5 + 0.25 * Math.sin(time*3+0.5);

			renderer.autoClear = false;
			renderer.clear();
			renderer.render(scene, camera);

			controls.update();

			stats.update();

			requestAnimationFrame(loop);
		}
		loop();
		
	});
	</script>
</head>
<body>
	<div id="threejs-container"></div>
</body>
</html>