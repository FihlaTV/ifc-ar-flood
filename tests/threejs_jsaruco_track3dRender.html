<!DOCTYPE html>
<html>
<head>
	<title>IFC - js-aruco - Track 3D Render</title>
	<meta charset="UTF-8"/>

	<link href='http://fonts.googleapis.com/css?family=Fauna+One' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/style.css">

	<!--load helper libraries-->
	<script type="text/javascript" src="/js/lib/jquery-2.0.2.min.js"></script>

	<!--load AR libraries-->
	<script type="text/javascript" src="/js/lib/ar/js-aruco/svd.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/posit1.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/cv.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/aruco.js"></script>

    <!--load 3D libraries-->
	<script type="text/javascript" src="/js/lib/three.min.js"></script>
	<script type="text/javascript" src="/js/lib/Detector.js"></script>
	<script type="text/javascript" src="/js/lib/stats.min.js"></script>
	<script type="text/javascript" src="/js/lib/dat.gui.min.js"></script>
	<script type="text/javascript" src="/js/lib/OrbitControls.js"></script>
	<script type="text/javascript" src="/js/lib/postprocessing/EffectComposer.js"></script>
	<script type="text/javascript" src="/js/lib/postprocessing/RenderPass.js"></script>
	<script type="text/javascript" src="/js/lib/postprocessing/ShaderPass.js"></script>
	<script type="text/javascript" src="/js/lib/postprocessing/MaskPass.js"></script>
	<script type="text/javascript" src="/js/lib/postprocessing/shaders/CopyShader.js"></script>
	<script type="text/javascript" src="/js/lib/postprocessing/shaders/FXAAShader.js"></script>

	<script>

	var MARKER_SIZE = 35.0;  //millimeters

	var clock = new THREE.Clock();
	var lookAtPoint = new THREE.Vector3();

	var options = {
	    trackingSceneFxaa: false,
	    cameraMotionAutoOrbit: false,
		cameraMotionRadius: 0.2,
		cameraMotionSpeed: 0.2,
		cameraMotionTiltAmp: 0.2,
		cameraMotionTiltOffset: 0.1,
		togglePauseOrbit: togglePauseOrbit,
		displayRefCube: true,
		displayDebugView: false,
		displayLocalAxis: false
	};

	function checkWebGl()
	{
		//check for WebGL
		if (!Detector.webgl)
		{
			$('div').remove();
			Detector.addGetWebGLMessage();
			throw new Error('Your browser does not seem to support WebGL');
		}
	}

    var trackSceneRenderer, trackSceneScene, trackSceneCamera, trackSceneCameraControls;
    var worldAxis;
    var refCubeMesh, refCubeMesh2;
    var composer;
    function setupThreejsTrackingScene()
    {
		//renderer
		trackSceneRenderer = new THREE.WebGLRenderer({
			antialias : true
		});
		trackSceneRenderer.setSize(canvasWidth, canvasHeight);
		trackSceneRenderer.setClearColor('#888888', 1);
		var $threejsTrackSceneContainerElem = $('#mainTracking3dScene');
		$threejsTrackSceneContainerElem.append(trackSceneRenderer.domElement);
		source = trackSceneRenderer.domElement;

		//scene
		trackSceneScene = new THREE.Scene();

		//camera
		trackSceneCamera = new THREE.PerspectiveCamera(40, canvasWidth/canvasHeight, 0.1, 1000);
		trackSceneCamera.position.set(0.25, 0.25, 0.25);
		trackSceneCamera.lookAt(new THREE.Vector3(0,0,0));
		trackSceneCameraControls = new THREE.OrbitControls(trackSceneCamera);
		trackSceneCameraControls.modifierKey = 'alt';
		trackSceneCameraControls.userPanSpeed = 0.04;
		trackSceneCameraControls.pan(new THREE.Vector3(0, 1, 0));
		trackSceneCameraControls.pan(new THREE.Vector3(0, 1, 0));

		//add world axis
		worldAxis = new THREE.AxisHelper(0.01);
		trackSceneScene.add(worldAxis);

		//plane
		var trackScenePlaneMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(0.1, 0.1, 2, 2),
			new THREE.MeshBasicMaterial({
				map: THREE.ImageUtils.loadTexture('/resources/markers/js-aruco/1001.png')
			})
		);
		trackScenePlaneMesh.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		trackSceneScene.add(trackScenePlaneMesh);

		// //plane 2
		// var trackScenePlaneMesh = new THREE.Mesh(
			// new THREE.PlaneGeometry(0.1, 0.1, 2, 2),
			// new THREE.MeshBasicMaterial({
				// map: THREE.ImageUtils.loadTexture('/resources/markers/js-aruco/446.png')
			// })
		// );
		// trackScenePlaneMesh.geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		// trackScenePlaneMesh.position.x = 0.11;
		// trackScenePlaneMesh.position.z = -0.05;
		// trackSceneScene.add(trackScenePlaneMesh);

		//reference cube
		refCubeMesh = new THREE.Mesh(
		    new THREE.CubeGeometry(0.1, 0.1, 0.1),
		    new THREE.MeshBasicMaterial({
		        color: 0x00ff00,
		        side: THREE.DoubleSide,wireframe: true,
		        depthTest : false,
		        depthWrite : false
		    })
		);
		refCubeMesh.position.y = 0.05;
		trackSceneScene.add(refCubeMesh);

		// //reference cube 2
		// refCubeMesh2 = new THREE.Mesh(
		    // new THREE.CubeGeometry(0.1, 0.1, 0.1),
		    // new THREE.MeshBasicMaterial({
		        // color: 0x00ff00,
		        // side: THREE.DoubleSide,wireframe: true,
		        // depthTest : false,
		        // depthWrite : false
		    // })
		// );
		// refCubeMesh2.position.x = 0.11;
		// refCubeMesh2.position.y = 0.05;
		// refCubeMesh2.position.z = -0.05;
		// trackSceneScene.add(refCubeMesh2);

		//effects composer
		composer = new THREE.EffectComposer(trackSceneRenderer);
		composer.addPass(new THREE.RenderPass(trackSceneScene, trackSceneCamera));
		var	pass = new THREE.ShaderPass(THREE.FXAAShader);
		pass.uniforms['resolution'].value.set(1.0/canvasWidth, 1.0/canvasHeight);
		pass.renderToScreen = true;
		composer.addPass(pass);
    }

    var detector, posit;
    function setupJsaruco()
    {
		detector = new AR.Detector();
		posit = new POS.Posit(MARKER_SIZE, canvasWidth);
    }

    var $threejsContainerElem;
    var renderer, scene, camera;
    var videoScene, videoCam, videoTex;
    function setupThreejsScene()
    {
		renderer = new THREE.WebGLRenderer({
			antialias : true
		});
		renderer.setSize(640, 480);  //fix the output size, will not affect tracking resolution
		renderer.shadowMapEnabled = true;
		renderer.shadowMapType = THREE.PCFShadowMap;
		renderer.shadowMapSoft = true;
		$threejsContainerElem = $('#threejs-container');
		$threejsContainerElem.append(renderer.domElement);

		// create the scene
		scene = new THREE.Scene();

		// Create a camera and a marker root object for your Three.js scene.
		camera = new THREE.PerspectiveCamera(40, canvasWidth / canvasHeight, 1, 1000);
		// camera.position.set(25,25,25);
		camera.matrixAutoUpdate = false;

		//setup lights
		scene.add(new THREE.AmbientLight(0x330015));

		keyLight = new THREE.SpotLight(0xffff00, 0.5);
		keyLight.position.set(25, 75, 75);
		keyLight.target.position.set(0, 0, 0);
		keyLight.castShadow = true;
		keyLight.shadowCameraNear = 60;
		keyLight.shadowCameraFar = 200;
		keyLight.shadowCameraFov = 70;
		// keyLight.shadowCameraVisible = true;
		keyLight.shadowBias = 0.0001;
		keyLight.shadowDarkness = 0.5;
		keyLight.shadowMapWidth = 1024;
		keyLight.shadowMapHeight = 1024;
		scene.add(keyLight);

		fillLight = new THREE.SpotLight(0x00ff00, 0.3);
		fillLight.position.set(25, 10, 75);
		fillLight.target.position.set(0, 0, 0);
		scene.add(fillLight);

		//create a ground plane at the origin
		var groundPlaneGeom = new THREE.PlaneGeometry(100, 100, 1, 1);
		groundPlaneGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		var groundPlaneMaterial = new THREE.MeshPhongMaterial({side: THREE.DoubleSide, wireframe: false});
		// materials.push(groundPlaneMaterial);
		groundPlaneMesh = new THREE.Mesh(groundPlaneGeom, groundPlaneMaterial);
		groundPlaneMesh.castShadow = true;
		groundPlaneMesh.receiveShadow = true;
		scene.add(groundPlaneMesh);

		// Create scene and quad for the video.
		// NOTE: must use <canvas> as the texture, not <video>, otherwise there will be a 1-frame lag
		videoTex = new THREE.Texture(canvas);
		var geometry = new THREE.PlaneGeometry(2, 2);
		var material = new THREE.MeshBasicMaterial({
			map : videoTex,
			depthTest : false,
			depthWrite : false
		});
		var plane = new THREE.Mesh(geometry, material );
		videoScene = new THREE.Scene();
		videoCam = new THREE.Camera();
		videoScene.add(plane);
		videoScene.add(videoCam);
    }

    function setupStats()
    {
        //create a stats monitor
		stats = new Stats();
		$threejsContainerElem.append(stats.domElement);
    }

    var gui;
	var trackingSceneFolder, cameraMotionFolder, displayFolder;
	function setupGui() {

		gui = new dat.GUI();
		gui.close();  //close GUI by default

		//tracking scene folder
		trackingSceneFolder = gui.addFolder('Tracking Scene');
		trackingSceneFolder.open();

		var control = trackingSceneFolder.add(options, 'trackingSceneFxaa').name('FXAA');

		//camera motion folder
		cameraMotionFolder = gui.addFolder('Camera Motion');
		cameraMotionFolder.open();

		control = cameraMotionFolder.add(options, 'cameraMotionAutoOrbit').name('Auto Orbit');
		function toggleCameraMotionAutoOrbit(value)
		{
		    //always turn orbiting on when auto orbit is turned on
			isOrbiting = true;
		}
		control.onChange(toggleCameraMotionAutoOrbit);

		control = cameraMotionFolder.add(options, 'cameraMotionRadius', 0.1, 1.0).name('Radius');

		control = cameraMotionFolder.add(options, 'cameraMotionSpeed', 0.1, 2.0).name('Speed');

		control = cameraMotionFolder.add(options, 'cameraMotionTiltAmp', 0.0, 1.0).name('Tilt Amp');

		control = cameraMotionFolder.add(options, 'cameraMotionTiltOffset', 0.0, 0.5).name('Tilt Offset');

		control = cameraMotionFolder.add(options, 'togglePauseOrbit').name('Pause');

		//display folder
		displayFolder = gui.addFolder('Display');
		displayFolder.open();

		control = displayFolder.add(options, 'displayRefCube').name('Reference Cube');
		function toggleRefCube(value)
		{
			refCubeMesh.visible = value;
			// refCubeMesh2.visible = value;
		}
		control.onChange(toggleRefCube);
		toggleRefCube(options.displayRefCube);

		control = displayFolder.add(options, 'displayDebugView').name('Debug View');

		control = displayFolder.add(options, 'displayLocalAxis').name('Local Axis');
		function toggleLocalAxis(value)
		{
			worldAxis.visible = value;
		}
		control.onChange(toggleLocalAxis);
		toggleLocalAxis(options.displayLocalAxis);
	}

	var isOrbiting = true;
	function togglePauseOrbit()
	{
	    isOrbiting = !isOrbiting;
	}

	function drawCorners(markers)
	{
        var corners, corner, i, j, leni, lenj;

        for (i = 0, leni = markers.length; i < leni; i++)
        {
            corners = markers[i].corners;

            ctx.lineWidth = 2;
            ctx.strokeStyle = "red";
            ctx.beginPath();

            for (j = 0, lenj = corners.length; j < lenj; j++)
            {
                corner = corners[j];
                ctx.moveTo(corner.x, corner.y);
                corner = corners[(j + 1) % corners.length];
                ctx.lineTo(corner.x, corner.y);
            }

            ctx.stroke();
            ctx.closePath();

            ctx.lineWidth = 3;
            ctx.strokeStyle = "green";
            ctx.strokeRect(corners[0].x - 2, corners[0].y - 2, 4, 4);
        }
    };

    function drawId(markers)
    {
        var corners, corner, x, y, i, len;

        ctx.font = '12pt Calibri';
        ctx.fillStyle = "yellow";
        // ctx.strokeStyle = "black";
        // ctx.lineWidth = 1.0;

        for (i = 0, len = markers.length; i < len; i++)
        {
            corners = markers[i].corners;

            x = corners[0].x;
            y = corners[0].y;

            ctx.fillText(markers[i].id, x, y);
            // ctx.strokeText(markers[i].id, x, y);
        }
    }

    var markerRoots = {};
    function updateScenes(markers)
    {
        var corners, corner, pose, i, markerId;

        //hide all marker roots first
        var keys = Object.keys(markerRoots);
        for (i = 0; i < keys.length; i++)
        {
            // showChildren(markerRoots[keys[i]], false);
        }

        for (i = 0; i < markers.length; i++)
        {
            markerId = markers[i].id;
            corners = markers[i].corners;

            //create a new marker root if this id has not been seen before
            if (!markerRoots[markerId])
            {
                console.log('creating new marker root for id: ' + markerId);
                markerRoot = new THREE.Object3D();
                markerRoot.matrixAutoUpdate = false;
                markerRoots[markerId] = markerRoot;
                var cubeLength = MARKER_SIZE * 0.98;
                var cubeGeom = new THREE.CubeGeometry(cubeLength, cubeLength, cubeLength);
                var cubeMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide,
                    wireframe: false
                });
                var cubeMesh = new THREE.Mesh(cubeGeom, cubeMaterial);
                cubeMesh.position.y = cubeLength / 2.0;
                cubeMesh.castShadow = true;
                cubeMesh.receiveShadow = true;
                markerRoot.add(cubeMesh);
                scene.add(markerRoot);

                //add a local axis for each marker root for debugging
                var localAxis = new THREE.AxisHelper(50);
                localAxis.visible = options.displayLocalAxis;
                // localAxes.push(localAxis);
                markerRoot.add(localAxis);
            }

            //align corners to center of canvas
            var j;
            for (j = 0; j < corners.length; j++)
            {
                corner = corners[j];
                corner.x = corner.x - (canvasWidth / 2);
                corner.y = (canvasHeight / 2) - corner.y;
            }

            //estimate pose
            try
            {
                pose = posit.pose(corners);

                showChildren(markerRoots[markerId], true);
                // updateMesh(markerRoots[markerId], pose.bestRotation, pose.bestTranslation);
                // updateMesh(markerRoots[markerId], pose.alternativeRotation, pose.alternativeTranslation);

                var r = createMatrix4FromPose(pose);
                r.multiply(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90)));

                //transform camera instead of the object
                camera.matrix = new THREE.Matrix4().getInverse(r);
                camera.matrixWorldNeedsUpdate = true;

                // updatePoseInfo("pose1", pose.bestError, pose.bestRotation, pose.bestTranslation);
                // updatePoseInfo("pose2", pose.alternativeError, pose.alternativeRotation, pose.alternativeTranslation);
            }
            catch(err)
            {
                //just print to console but let the error pass so that the program can continue
                console.log(err.message);
            }
        }
    };

    function createMatrix4FromPose(pose)
	{
        return new THREE.Matrix4(
            pose.bestRotation[0][0], pose.bestRotation[0][1], -pose.bestRotation[0][2], pose.bestTranslation[0],
            pose.bestRotation[1][0], pose.bestRotation[1][1], -pose.bestRotation[1][2], pose.bestTranslation[1],
            -pose.bestRotation[2][0], -pose.bestRotation[2][1], pose.bestRotation[2][2], -pose.bestTranslation[2],
            0, 0, 0, 1
        );
	}

    function showChildren(object3d, visible)
    {
        var i, len;
        var children = object3d.children;
        for (i = 0, len = children.length; i < len; i++)
        {
            children[i].visible = visible;
        }
    }

    function updateMesh(mesh, rotation, translation)
    {
        //convert into matrix so that it's easier to do transformations
        var r = new THREE.Matrix4();
        r.elements[0] = rotation[0][0];
        r.elements[1] = rotation[1][0];
        r.elements[2] = -rotation[2][0];
        r.elements[3] = 0;
        r.elements[4] = rotation[0][1];
        r.elements[5] = rotation[1][1];
        r.elements[6] = -rotation[2][1];
        r.elements[7] = 0;
        r.elements[8] = -rotation[0][2];
        r.elements[9] = -rotation[1][2];
        r.elements[10] = rotation[2][2];
        r.elements[11] = 0;
        r.elements[12] = translation[0];
        r.elements[13] = translation[1];
        r.elements[14] = -translation[2];
        r.elements[15] = 1;
        mesh.matrix = r;
        mesh.matrix.multiply(new THREE.Matrix4().makeRotationX(THREE.Math.degToRad(90)));
        mesh.matrixWorldNeedsUpdate = true;

        //THESE ARE CALCULATIONS FROM JS-ARUCO EXAMPLES:

        // mesh.scale.x = MARKER_SIZE;
        // mesh.scale.y = MARKER_SIZE;
        // mesh.scale.z = MARKER_SIZE;

        // mesh.rotation.x = -Math.asin(-rotation[1][2]);
        // mesh.rotation.y = -Math.atan2(rotation[0][2], rotation[2][2]);
        // mesh.rotation.z = Math.atan2(rotation[1][0], rotation[1][1]);

        // mesh.position.x = translation[0];
        // mesh.position.y = translation[1];
        // mesh.position.z = -translation[2];
    };

    function updatePoseInfo(id, error, rotation, translation)
    {
        var yaw = -Math.atan2(rotation[0][2], rotation[2][2]);
        var pitch = -Math.asin(-rotation[1][2]);
        var roll = Math.atan2(rotation[1][0], rotation[1][1]);

        var d = document.getElementById(id);
        d.innerHTML = " error: " + error
                  + "<br/>"
                  + " x: " + (translation[0] | 0)
                  + " y: " + (translation[1] | 0)
                  + " z: " + (translation[2] | 0)
                  + "<br/>"
                  + " yaw: " + Math.round(-yaw * 180.0/Math.PI)
                  + " pitch: " + Math.round(-pitch * 180.0/Math.PI)
                  + " roll: " + Math.round(roll * 180.0/Math.PI);
    };

    var canvas, canvasWidth, canvasHeight;
    var ctx;
    var markers = {};
    var t = 0;
	$(document).ready(function()
	{
	    //check for WebGL
		checkWebGl();

		console.log('Document is ready.');

		//get canvas
		canvas = $('#mainCanvas')[0];
		canvasWidth = canvas.width;
		canvasHeight = canvas.height;
		ctx = canvas.getContext('2d');

		//setup tracking scene
		setupThreejsTrackingScene();

		//setup js-aruco
		setupJsaruco();

		//setup scene
		setupThreejsScene();

		//setup stats monitor
		setupStats();

		//setup GUI
		setupGui();

		//main loop
		function loop()
		{
			var dt = clock.getDelta();  //have to call this before getElapsedTime()
			var time = clock.getElapsedTime();

			//update tracking camera
			if (options.cameraMotionAutoOrbit)
			{
			    if (isOrbiting)
			    {
                    t += dt;
                    trackSceneCamera.position.x = options.cameraMotionRadius * Math.sin(options.cameraMotionSpeed * t);
                    trackSceneCamera.position.y = (options.cameraMotionTiltAmp / 2.0) * Math.sin(options.cameraMotionSpeed * t) + (options.cameraMotionTiltAmp / 2.0) + options.cameraMotionTiltOffset;
                    trackSceneCamera.position.z = options.cameraMotionRadius * Math.cos(options.cameraMotionSpeed * t);
                    trackSceneCamera.lookAt(lookAtPoint);
                }
			}
			else
			{
			    trackSceneCameraControls.update();
			}

			//update tracking scene
			trackSceneRenderer.autoClear = false;
			trackSceneRenderer.clear();
			if (options.trackingSceneFxaa)
			{
			    composer.render(trackSceneScene, trackSceneCamera);
			}
			else
			{
			    trackSceneRenderer.render(trackSceneScene, trackSceneCamera);
			}

            //draw the video frame to the canvas
            ctx.drawImage(source, 0, 0, canvasWidth, canvasHeight);
            var imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);

            //detect markers
            var markers = detector.detect(imageData);
            if (options.displayDebugView)
            {
                drawCorners(markers);
                drawId(markers);
            }

            //update scene
            updateScenes(markers);

            //update the video texture
            videoTex.needsUpdate = true;

            //render the scene
            renderer.autoClear = false;
            renderer.clear();
            renderer.render(videoScene, videoCam);
            renderer.render(scene, camera);

            //update stats
            stats.update();

			requestAnimationFrame(loop);
		}
		loop();
	});
	</script>
</head>
<body>
	<h2>Three.js and js-aruco</h2>

	<div class="container" id="mainTracking3dScene">
		<div class="caption">Three.js 3D scene for tracking</div>
	</div>

	<div class="container" id="canvas-container">
		<div class="caption">&lt;canvas&gt;</div>
		<canvas id="mainCanvas" width="640" height="480"></canvas>
	</div>

	<div class="container" id="threejs-container">
		<div class="caption">three.js &lt;canvas&gt;</div>
	</div>

	<div class="container" id="pose1-container">
	    <div class="caption">Best Estimated Pose Info</div>
	    <div class="caption" id="pose1"></div>
	</div>
	<div class="container" id="pose2-container">
	    <div class="caption">Alternative Estimated Pose Info</div>
	    <div class="caption" id="pose2"></div>
	</div>
</body>
</html>