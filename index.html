<!DOCTYPE html>
<html>
<head>
	<title>IFC - HTML5 Augmented Reality Flood Simulation</title>
	<meta charset="UTF-8"/>

	<link href='http://fonts.googleapis.com/css?family=Fauna+One' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/style.css">
	<style type="text/css">
		#stats { position: absolute; top:0; left: 0 }
		#stats #fps { background: transparent !important }
		#stats #fps #fpsText { color: #aaa !important }
		#stats #fps #fpsGraph { display: block }
	</style>

	<!--load helper libraries-->
	<script type="text/javascript" src="/js/lib/jquery-2.0.2.min.js"></script>

	<!--load 3D libraries-->
	<script type="text/javascript" src="/js/lib/three.min.js"></script>
	<script type="text/javascript" src="/js/lib/Detector.js"></script>
	<script type="text/javascript" src="/js/lib/stats.min.js"></script>
	<script type="text/javascript" src="/js/lib/dat.gui.min.js"></script>
	<script type="text/javascript" src="/js/lib/OBJMTLLoader.js"></script>
	<script type="text/javascript" src="/js/lib/MTLLoader.js"></script>
	<script type="text/javascript" src="/js/lib/BinaryLoader.js"></script>
	<script type="text/javascript" src="/js/lib/OrbitControls.js"></script>

	<!--load AR libraries-->
	<script type="text/javascript" src="/js/lib/ar/jsartoolkit/JSARToolKit.min.js"></script>
	<script type="text/javascript" src="/js/lib/ar/js-aruco/svd.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/posit1.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/cv.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/aruco.js"></script>
	<script type="text/javascript" src="/js/skarf.js"></script>

	<!--load webcam streaming libraries-->
	<script type="text/javascript" src="/js/lib/webrtc_adapter.js"></script>
	<script type="text/javascript" src="/js/streamvideo.js"></script>

	<script>

	var ARLIB = 'jsaruco';
	// var ARLIB = 'jsartoolkit';
	var MARKER_SIZE = 25;  //in mm
	var JSARTOOLKIT_MARKERS_JSON = '/resources/models/models_jsartoolkit_main.json';
	var JSARUCO_MARKERS_JSON = '/resources/models/models_jsaruco_main.json';

	var SHADOW_MAP_RES = 1024;
	var TERRAIN_RES = 256;
	var TERRAIN_SIZE = 8;

	var options = {
        trackingThreshold: 128,
        sculptSize: 1.0,
        displayWireframe: false,
        displayLocalAxis: true,
        displayOriginPlane: true,
    };

	var clock = new THREE.Clock();

	function checkWebGl()
	{
		//check for WebGL
		if (!Detector.webgl)
		{
			$('div').remove();
			Detector.addGetWebGLMessage();
			throw new Error('Your browser does not seem to support WebGL');
		}
	}

	var video, source;
	function setupVideo()
	{
	    video = $('#mainVideo')[0];
        streamVideo(video);
        source = video;
	}

	var renderer, scene, camera;
	var keyLight, fillLight;
	// var worldAxis, localAxis;
	var materials = [];
	var groundPlaneMesh;
	function setupMainScene()
	{
		//create renderer
		renderer = new THREE.WebGLRenderer({
			antialias : true
		});
		renderer.setSize(window.innerWidth, window.innerHeight-5);
		renderer.setClearColor('#081419', 1);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapType = THREE.PCFShadowMap;
		renderer.shadowMapSoft = true;
		$threejsContainerElem.append(renderer.domElement);

		//create scene
		scene = new THREE.Scene();

		//create camera
		camera = new THREE.PerspectiveCamera(25, renderer.domElement.width/renderer.domElement.height, 0.1, 1000);
		camera.position.set(8, 8, 15);
		camera.lookAt(new THREE.Vector3(0,0,0));
		camera.matrixAutoUpdate = false;

		//create controls for camera
		controls = new THREE.OrbitControls(camera);
		controls.userPanSpeed = 0.2;
		//controls.autoRotate = true;
		controls.modifierKey = 'alt';

		//create plane for reference and for intersection test
		var groundPlaneGeom = new THREE.PlaneGeometry(TERRAIN_SIZE * MARKER_SIZE, TERRAIN_SIZE * MARKER_SIZE, 1, 1);  //much faster for intersection test when there are no divisions
		groundPlaneGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		var groundPlaneMaterial = new THREE.MeshPhongMaterial({
		    color: 0x99ff66
		});
		materials.push(groundPlaneMaterial);
		groundPlaneMesh = new THREE.Mesh(groundPlaneGeom, groundPlaneMaterial);
		// groundPlaneMesh.position.x = TERRAIN_SIZE * MARKER_SIZE / 2.0;
		// groundPlaneMesh.position.z = - TERRAIN_SIZE * MARKER_SIZE / 2.0;
		groundPlaneMesh.castShadow = true;
		groundPlaneMesh.receiveShadow = true;
		groundPlaneMesh.visible = true;
		scene.add(groundPlaneMesh);

		//create axis
		// worldAxis = new THREE.AxisHelper();
		// scene.add(worldAxis);
		// localAxis = new THREE.AxisHelper();
		// scene.add(localAxis);

		//setup lights
		scene.add(new THREE.AmbientLight(0x111111));

        var keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
        keyLight.position.set(-50, 75, 75);
        keyLight.target.position.set(0, 0, 0);
        keyLight.castShadow = true;
        keyLight.shadowCameraNear = 60;
        keyLight.shadowCameraFar = 200;
        keyLight.shadowCameraRight = 150;
        keyLight.shadowCameraLeft = -150;
        keyLight.shadowCameraTop = 150;
        keyLight.shadowCameraBottom = -150;
        // keyLight.shadowCameraVisible = true;
        keyLight.shadowBias = 0.0001;
        keyLight.shadowDarkness = 0.5;
        keyLight.shadowMapWidth = 1024;
        keyLight.shadowMapHeight = 1024;
        scene.add(keyLight);

        var fillLight = new THREE.DirectionalLight(0xffffff, 0.7);
        fillLight.position.set(25, 75, 75);
        fillLight.target.position.set(0, 0, 0);
        scene.add(fillLight);
	}

	var skarf;
	function setupAr()
	{
		//create a SkArF framework
		if (ARLIB === 'jsartoolkit') {
		    skarf = new SkArF({

                arLibType: 'jsartoolkit',
                trackingElem: source,
                markerSize: MARKER_SIZE,
                //NOTE: not using verticalFov for now because the JSARToolKit default projection matrix seems to work better
                //verticalFov: 40,  //you will have to estimate this for your camera
                threshold: options.trackingThreshold,
                debug: false,

                canvasContainerElem: $canvasContainerElem,

                rendererType: 'threejs',
                renderer: renderer,
                scene: scene,
                camera: camera,

                markersJsonFile: JSARTOOLKIT_MARKERS_JSON

            });
		} else if (ARLIB === 'jsaruco') {
		    skarf = new SkArF({

                arLibType: 'jsaruco',
                trackingElem: source,
                markerSize: MARKER_SIZE,
                verticalFov: 40,  //you will have to estimate this for your camera
                debug: false,

                canvasContainerElem: $canvasContainerElem,

                rendererType: 'threejs',
                renderer: renderer,
                scene: scene,
                camera: camera,

                markersJsonFile: JSARUCO_MARKERS_JSON

            });
		} else {
		    throw new Error('ARLIB type not recognised: ' + ARLIB);
		}

	}

	function setupEvents()
	{
		window.addEventListener('resize', window_onResize, false);
		// window.addEventListener('keyup', window_onKeyUp, false);
		// window.addEventListener('mousedown', window_onMouseDown, false);
		// window.addEventListener('mousemove', window_onMouseMove, false);
		// window.addEventListener('mouseup', window_onMouseUp, false);
	}

	function window_onResize(event)
	{
	    var width, height;

	    //calculate width and height that maintains video aspect ratio
	    var videoAspect = video.width / video.height;
	    var windowAspect = window.innerWidth / window.innerHeight;
	    if (windowAspect > videoAspect)
	    {
	        width = window.innerHeight * 4 / 3;
	        height = window.innerHeight - 5;
	    }
	    else
	    {
	        width = window.innerWidth;
	        height = (window.innerWidth * 3 / 4) - 5;
	    }

		//update renderer size
		skarf.renderer.renderer.setSize(width, height);
	}

	function setupStats()
	{
		//create a stats monitor
		stats = new Stats();
		$('body').append(stats.domElement);
	}

    var gui;
    var trackingFolder, sculptFolder, displayFolder;
    var trackingThresholdControl;
    var sculptSizeControl;
	function setupGui() {

		gui = new dat.GUI();
		// gui.close();  //close GUI by default

		var control;

		//Tracking folder
		trackingFolder = gui.addFolder('Tracking');
		trackingFolder.open();

		trackingThresholdControl = trackingFolder.add(options, 'trackingThreshold', 0, 255).name('Threshold').listen();
		changeTrackingThreshold = function (value)
		{
		    value = THREE.Math.clamp(value, trackingThresholdControl.__min, trackingThresholdControl.__max);
			skarf.arLib.threshold = value;
			options.trackingThreshold = value;
		}
		trackingThresholdControl.onChange(changeTrackingThreshold);

		//Sculpt folder
		sculptFolder = gui.addFolder('Sculpt');
		sculptFolder.open();

		sculptSizeControl = sculptFolder.add(options, 'sculptSize', 0.1, 10.0).name('Size').listen();
		changeSculptSize = function (value)
		{
		    value = THREE.Math.clamp(value, sculptSizeControl.__min, sculptSizeControl.__max);
			// gpuSkulpt.setBrushSize(value);
			options.sculptSize = value;
		}
		sculptSizeControl.onChange(changeSculptSize);
		changeSculptSize(options.sculptSize);

		//Display folder
		displayFolder = gui.addFolder('Display');
		displayFolder.open();

		control = displayFolder.add(options, 'displayWireframe').name('Wireframe').listen();
		toggleWireframe = function (value)
		{
			skarf.renderer.setWireframeVisible(value);
			var i, len;
			for (i = 0, len = materials.length; i < len; i++)
			{
			    materials[i].wireframe = value;
			}
			options.displayWireframe = value;
		}
		control.onChange(toggleWireframe);
		toggleWireframe(options.displayWireframe);

		control = displayFolder.add(options, 'displayLocalAxis').name('Local Axis').listen();
		toggleLocalAxis = function (value)
		{
			skarf.renderer.setLocalAxisVisible(value);
			options.displayLocalAxis = value;
		}
		control.onChange(toggleLocalAxis);
		toggleLocalAxis(options.displayLocalAxis);

		control = displayFolder.add(options, 'displayOriginPlane').name('Origin Plane').listen();
		toggleOriginPlane = function (value)
		{
			skarf.renderer.setOriginPlaneVisible(value);
			options.displayOriginPlane = value;
		}
		control.onChange(toggleOriginPlane);
		toggleOriginPlane(options.displayOriginPlane);
	}

	function setupGuiMarkerCallbacks() {

	    //NOTE: not allowing changing of tracking threshold using marker
	    //because once you get into an undetectable threshold, you can't use the marker to control anymore
	    // trackingThresholdSliderCB = function (params) {
            // changeTrackingThreshold(options.trackingThreshold + params.dy * 2.0);
        // };

	    sculptSizeSliderCB = function (params) {
            changeSculptSize(options.sculptSize + params.dy * 2.0);
        };
        clearSculptsButtonCB = function (params) {
            console.log('clear sculpts');
        };
        displayWireframeCB = function (params) {
            toggleWireframe(params.activated);
        };
        displayLocalAxisCB = function (params) {
            toggleLocalAxis(params.activated);
        };
        displayOriginPlaneCB = function (params) {
            toggleOriginPlane(params.activated);
        };
    }

	var $canvasContainerElem, $threejsContainerElem;
	$(document).ready(function()
	{
		//check for WebGL
		checkWebGl();

		console.log('Document is ready.');

		$threejsContainerElem = $('#threejs-container');
		$canvasContainerElem = $('#canvas-container');

		//stream to video element
		setupVideo();

		//setup main scene
		setupMainScene();

		//setup AR
		setupAr();

		//setup events
		setupEvents();

		//setup stats monitor
		setupStats();

		//setup GUI marker callbacks
		setupGuiMarkerCallbacks();

		//setup GUI
		setupGui();

		//main loop
		function loop()
		{
			var time = clock.getElapsedTime();

			skarf.update();
			stats.update();

			requestAnimationFrame(loop);
		}
		loop();

	});
	</script>
</head>
<body>
    <div class="invisible" id="video-container">
		<div class="caption">&lt;video&gt;</div>
		<video id="mainVideo" width="640" height="480" autoplay="autoplay" muted="true"></video>
	</div>
	<div class="invisible" id="canvas-container">
		<div class="caption">&lt;canvas&gt;</div>
	</div>
	<div class="invisible" id="debugCanvas-container">
		<div class="caption">debug &lt;canvas&gt;</div>
		<canvas id="debugCanvas" width="640" height="480"></canvas>
	</div>
	<div id="threejs-container"></div>
</body>
</html>