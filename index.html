<!DOCTYPE html>
<html>
<head>
	<title>IFC - HTML5 Augmented Reality Flood Simulation</title>
	<meta charset="UTF-8"/>

	<link href='http://fonts.googleapis.com/css?family=Fauna+One' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" href="/css/style.css">
	<style type="text/css">
		#stats { position: absolute; top:0; left: 0 }
		#stats #fps { background: transparent !important }
		#stats #fps #fpsText { color: #aaa !important }
		#stats #fps #fpsGraph { display: block }
	</style>

	<!--load helper libraries-->
	<script type="text/javascript" src="/js/lib/jquery-2.0.2.min.js"></script>

	<!--load 3D libraries-->
	<script type="text/javascript" src="/js/lib/three.min.js"></script>
	<script type="text/javascript" src="/js/lib/Detector.js"></script>
	<script type="text/javascript" src="/js/lib/stats.min.js"></script>
	<script type="text/javascript" src="/js/lib/threex.rendererstats.js"></script>
	<script type="text/javascript" src="/js/lib/dat.gui.min.js"></script>
	<script type="text/javascript" src="/js/lib/OBJMTLLoader.js"></script>
	<script type="text/javascript" src="/js/lib/MTLLoader.js"></script>
	<script type="text/javascript" src="/js/lib/BinaryLoader.js"></script>
	<script type="text/javascript" src="/js/lib/OrbitControls.js"></script>

	<!--load AR libraries-->
	<script type="text/javascript" src="/js/lib/ar/jsartoolkit/JSARToolKit.min.js"></script>
	<script type="text/javascript" src="/js/lib/ar/js-aruco/svd.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/posit1.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/cv.js"></script>
    <script type="text/javascript" src="/js/lib/ar/js-aruco/aruco.js"></script>
	<script type="text/javascript" src="/js/skarf.js"></script>

	<!--load webcam streaming libraries-->
	<script type="text/javascript" src="/js/lib/webrtc_adapter.js"></script>
	<script type="text/javascript" src="/js/streamvideo.js"></script>

	<!--load terrain libraries-->
	<script type="text/javascript" src="/js/ShaderManager.js"></script>
	<script type="text/javascript" src="/js/skulptgpu.js"></script>
	<script type="text/javascript" src="/js/lib/SimplexNoise.js"></script>
	<script type="text/javascript" src="/js/lib/StackBlur.js"></script>

	<!--load RBD libraries-->
	<script type="text/javascript" src="/js/lib/physics/physi.js"></script>

	<script>

	// var ARLIB = 'jsaruco';
	var ARLIB = 'jsartoolkit';
	var CAM_VERTICAL_FOV = 40;  //estimate for your camera
	var JSARTOOLKIT_MARKERS_JSON = '/resources/models/models_jsartoolkit_main.json';
	var JSARUCO_MARKERS_JSON = '/resources/models/models_jsaruco_main.json';

	var SHADOW_MAP_RES = 1024;
	var TERRAIN_RES = 256;
	var TERRAIN_SIZE = 6;
	var TERRAIN_GRID_SIZE = TERRAIN_SIZE / TERRAIN_RES;
	var USE_TERRAIN_IMAGE = true;
	var TERRAIN_SCULPT_SIZE = 1.0;
	var TERRAIN_SCULPT_AMOUNT = 0.1;

	var PROXY_TERRAIN_RES = 64;  //Physijs will slow down if height field mesh is too large
	var TERRAIN_FRICTION = 0.8;
    var TERRAIN_RESTITUTION = 0.2;

	var terrainHalfSize = TERRAIN_SIZE / 2.0;

	var terrainImages = {
		'IGMS1':'/resources/images/terrain/IGMS/igms_693432,4598934,694456,4599958_512.jpg',
		'IGMS2':'/resources/images/terrain/IGMS/igms_617851,4595749,620411,4598309_512.jpg',
		'IGMS3':'/resources/images/terrain/IGMS/igms_640934,4596481,643494,4599041_512.jpg',
		'IGMS4':'/resources/images/terrain/IGMS/igms_678336,4595147,680896,4597707_512.jpg',
		'IGMS5':'/resources/images/terrain/IGMS/igms_679104,4595950,680128,4596974_512.jpg',
		'Clouds':'/resources/images/terrain/clouds_256.png'
	};
	var terrainImageSettings = {
		'/resources/images/terrain/IGMS/igms_693432,4598934,694456,4599958_512.jpg': { 'preblur':2, 'height':0.3, 'midGreyIsLowest':true },
		'/resources/images/terrain/IGMS/igms_617851,4595749,620411,4598309_512.jpg': { 'preblur':1, 'height':0.3, 'midGreyIsLowest':true },
		'/resources/images/terrain/IGMS/igms_640934,4596481,643494,4599041_512.jpg': { 'preblur':3, 'height':0.3, 'midGreyIsLowest':true },
		'/resources/images/terrain/IGMS/igms_678336,4595147,680896,4597707_512.jpg': { 'preblur':2, 'height':0.3, 'midGreyIsLowest':true },
		'/resources/images/terrain/IGMS/igms_679104,4595950,680128,4596974_512.jpg': { 'preblur':3, 'height':0.3, 'midGreyIsLowest':true },
		'/resources/images/terrain/clouds_256.png': { 'preblur':0, 'height':2, 'midGreyIsLowest':false }
	}
	var objects = {
		'Bench': 49,
		'Police Car': 31,
		'House': 63
	};

	var options = {
	    arOn: false,
        arTrackingThreshold: 128,
        terrainImage: terrainImages[Object.keys(terrainImages)[0]],
		terrainMidGreyIsLowest: true,
		terrainPreBlur: terrainImageSettings[Object.keys(terrainImageSettings)[0]].preblur,
		terrainHeight: terrainImageSettings[Object.keys(terrainImageSettings)[0]].height,
        sculptSize: 1.0,
        sculptAmount: TERRAIN_SCULPT_AMOUNT,
		sculptClearSculpts: sculptClearSculpts,
		objectsObject: objects[Object.keys(objects)[0]],
		objectsAddObject: objectsAddObject,
		objectsRemoveObject: objectsRemoveObject,
        displayWireframe: false,
        displayLocalAxis: false,
        debugTrackingInfo: false,
        debugTerrainImage: false,
        debugSculptTexture: false
    };

	var clock = new THREE.Clock();

	//config Physijs
	Physijs.scripts.worker = '/js/lib/physics/physijs_worker.js';
	Physijs.scripts.ammo = '/js/lib/physics/ammo.js';

	function checkWebGl()
	{
		//check for WebGL
		if (!Detector.webgl)
		{
			$('div').remove();
			Detector.addGetWebGLMessage();
			throw new Error('Your browser does not seem to support WebGL');
		}
	}

	var video, source;
	function setupVideo()
	{
	    video = $('#mainVideo')[0];
        source = video;
	}

	var renderer, scene, camera;
	var controls;
	var keyLight, fillLight;
	// var worldAxis, localAxis;
	var materials = [];
	var groundPlaneMesh;
	var markerManager;
	function setupMainScene()
	{
		//create renderer
		renderer = new THREE.WebGLRenderer({
			antialias : true
		});
		renderer.setSize(window.innerWidth, window.innerHeight-5);
		renderer.setClearColor('#081419', 1);
		renderer.shadowMapEnabled = true;
		renderer.shadowMapType = THREE.PCFShadowMap;
		renderer.shadowMapSoft = true;
		renderer.domElement.id = 'threejs-canvas';
		$threejsContainerElem.append(renderer.domElement);

		//create scene
		scene = new Physijs.Scene({ fixedTimeStep: 1 / 60 });
		scene.addEventListener(
			'ready',
			function() {
				console.log('Physijs scene is ready');
				setupDynamicAttributes();
			}
		);
		scene.addEventListener(  //https://github.com/chandlerprall/Physijs/issues/19
			'update',
			function() {
				scene.simulate(undefined, 1);
				physijsStats.update();
			}
		);
		// scene.setGravity(new THREE.Vector3(0, -5, 0));

		//create camera
		camera = new THREE.PerspectiveCamera(CAM_VERTICAL_FOV, video.width / video.height, 0.1, 1000);
		camera.position.set(4, 4, 7);
		camera.lookAt(new THREE.Vector3(0,0,0));

		//create controls for camera
		controls = new THREE.OrbitControls(camera);
		controls.userPanSpeed = 0.2;
		controls.modifierKey = 'alt';

		//create plane for reference and for intersection test
		var groundPlaneGeom = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, 1, 1);  //much faster for intersection test when there are no divisions
		groundPlaneGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		var groundPlaneMaterial = new THREE.MeshPhongMaterial({
		    color: 0x99ff66
		});
		materials.push(groundPlaneMaterial);
		groundPlaneMesh = new THREE.Mesh(groundPlaneGeom, groundPlaneMaterial);
		groundPlaneMesh.castShadow = true;
		groundPlaneMesh.receiveShadow = true;
		groundPlaneMesh.visible = false;
		scene.add(groundPlaneMesh);

		//create axis
		// worldAxis = new THREE.AxisHelper();
		// scene.add(worldAxis);
		// localAxis = new THREE.AxisHelper();
		// scene.add(localAxis);

		//setup lights
		scene.add(new THREE.AmbientLight(0x111111));

        var keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
        keyLight.position.set(-50, 75, 75);
        keyLight.target.position.set(0, 0, 0);
        keyLight.castShadow = true;
        keyLight.shadowCameraNear = 60;
        keyLight.shadowCameraFar = 200;
        keyLight.shadowCameraRight = 150;
        keyLight.shadowCameraLeft = -150;
        keyLight.shadowCameraTop = 150;
        keyLight.shadowCameraBottom = -150;
        // keyLight.shadowCameraVisible = true;
        keyLight.shadowBias = 0.0001;
        keyLight.shadowDarkness = 0.5;
        keyLight.shadowMapWidth = 1024;
        keyLight.shadowMapHeight = 1024;
        scene.add(keyLight);

        var fillLight = new THREE.DirectionalLight(0xffffff, 0.7);
        fillLight.position.set(25, 75, 75);
        fillLight.target.position.set(0, 0, 0);
        scene.add(fillLight);

        //also create a marker manager to load in markers
        if (ARLIB === 'jsartoolkit')
        {
            markerManager = new MarkerManager(JSARTOOLKIT_MARKERS_JSON);
        }
        else if (ARLIB === 'jsaruco')
        {
            markerManager = new MarkerManager(JSARUCO_MARKERS_JSON);
        }
        else
        {
            throw new Error('ARLIB type not recognised: ' + ARLIB);
        }
        markerManager.load();
	}

	function setupDynamicAttributes()
	{
		//setup attributes that need scene.world to be created first
		// var dynMesh;
		// for (dynMeshId in dynMeshes)
		// {
			// dynMesh = dynMeshes[dynMeshId];
			// dynMesh.setDamping(0.9, 0.9);
		// }
	}

	var terrainGeom, terrainMaterial, terrainMesh, skulptTerrainMesh;
	var gpuSkulpt;
	var $sculptedTerrainTextureCanvasElem, $sculptedTerrainTextureCanvasContainer, sculptedTerrainTextureContext, sculptedTerrainTextureImage;
	var $proxyTerrainTextureCanvasElem, $proxyTerrainTextureCanvasContainer, proxyTerrainTextureContext;
	var visGeom, visMaterial, visMesh;
	var proxyTerrainGeom, proxyTerrainMaterial, proxyTerrainMesh;
	function setupSkulpt()
	{
		//create a terrain mesh for sculpting
		terrainGeom = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_RES-1, TERRAIN_RES-1);
		terrainGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
		terrainGeom.computeFaceNormals();
	    terrainGeom.computeVertexNormals();
	    terrainGeom.normalsNeedUpdate = true;
		terrainMaterial = new THREE.MeshPhongMaterial({
		    color: 0xffffff,
		    wireframe: true
		});
		materials.push(terrainMaterial);
		terrainMesh = new THREE.Mesh(terrainGeom, terrainMaterial);
		terrainMesh.castShadow = true;
		terrainMesh.receiveShadow = true;
		terrainMesh.visible = true;
		scene.add(terrainMesh);

		//create a GpuSkulpt
		gpuSkulpt = new GpuSkulpt({
		    renderer: renderer,
			mesh: terrainMesh,
			size: TERRAIN_SIZE,
			res: TERRAIN_RES,
		});

		//change some parameters
		gpuSkulpt.mesh.material.uniforms.uPointLightIntensity.value[1] = 0.2;

		//create a canvas to handle the texture obtained from the sculpted terrain
		$sculptedTerrainTextureCanvasElem = $(document.createElement('canvas'));
		$sculptedTerrainTextureCanvasElem[0].id = 'sculptedTerrainImageCanvas';
		$sculptedTerrainTextureCanvasElem[0].width = TERRAIN_RES;
		$sculptedTerrainTextureCanvasElem[0].height = TERRAIN_RES;
		$sculptedTerrainTextureCanvasContainer = $('#sculptedTerrainTextureCanvas-container');
		$sculptedTerrainTextureCanvasContainer.append($sculptedTerrainTextureCanvasElem);
		sculptedTerrainTextureContext = $sculptedTerrainTextureCanvasElem[0].getContext('2d');
		sculptedTerrainTextureImage = sculptedTerrainTextureContext.createImageData(TERRAIN_RES, TERRAIN_RES);

		//create a scaled-down canvas to scale (and flip) the texture obtained from the sculpted terrain
		$proxyTerrainTextureCanvasElem = $(document.createElement('canvas'));
		$proxyTerrainTextureCanvasElem[0].id = 'proxyTerrainImageCanvas';
		$proxyTerrainTextureCanvasElem[0].width = PROXY_TERRAIN_RES;
		$proxyTerrainTextureCanvasElem[0].height = PROXY_TERRAIN_RES;
		$sculptedTerrainTextureCanvasContainer.append($proxyTerrainTextureCanvasElem);
		proxyTerrainTextureContext = $proxyTerrainTextureCanvasElem[0].getContext('2d');
		proxyTerrainTextureContext.scale(1, -1);  //flip the image veritcally

		//create a RTT visualization plane
		visGeom = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, 1, 1);
		visGeom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI/2));
	    visMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, map: gpuSkulpt.rttCombinedLayer } );
		materials.push(visMaterial);
		visMesh = new THREE.Mesh(visGeom, visMaterial);
		visMesh.position.y = 3;
		visMesh.castShadow = true;
		visMesh.receiveShadow = true;
		scene.add(visMesh);

		//also create a proxy mesh for Physijs collision
		proxyTerrainGeom = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, PROXY_TERRAIN_RES-1, PROXY_TERRAIN_RES-1);
		var v = proxyTerrainGeom.vertices;
		var i, len;
		for (i = 0, len = v.length; i < len; i++)
		{
			v[i].z = 0.5 * Math.cos(3 * v[i].x);
		}
		// proxyTerrainGeom.computeFaceNormals();
	    // proxyTerrainGeom.computeVertexNormals();
	    // proxyTerrainGeom.normalsNeedUpdate = true;
		proxyTerrainMaterial = Physijs.createMaterial(
		    new THREE.MeshPhongMaterial({
                color: 0xffffff,
                wireframe: false
            }),
            TERRAIN_FRICTION,
            TERRAIN_RESTITUTION
        );
		materials.push(proxyTerrainMaterial);
		createPhysijsHeightfieldMesh();

		scene.remove(proxyTerrainMesh);
		for (i = 0, len = v.length; i < len; i++)
		{
			v[i].z = 0.0;
		}
		createPhysijsHeightfieldMesh();
	}

	function createPhysijsHeightfieldMesh()
	{
	    proxyTerrainMesh = new Physijs.HeightfieldMesh(proxyTerrainGeom, proxyTerrainMaterial, 0);
		proxyTerrainMesh.rotation.x = -Math.PI/2;
		proxyTerrainMesh.castShadow = true;
		proxyTerrainMesh.receiveShadow = true;
		proxyTerrainMesh.visible = true;
		scene.add(proxyTerrainMesh);
	}

	var terrainImageData, terrainImageProcessedData;
	function filterTerrainImageAndGenerateHeight()
	{
		//draw image onto canvas
		//NO NEED TO DO THIS WHEN USING stackBlurImage()
        //imageCanvasElemContext.drawImage($scaledImageObj, 0, 0, terrainImageWidth, terrainImageHeight);

        //do pre-blur filtering first
        stackBlurImage('scaledTerrainImage', 'terrainImageCanvas', options.terrainPreBlur, false);

        //get filtered image data
        terrainImageData = imageCanvasElemContext.getImageData(0, 0, TERRAIN_RES, TERRAIN_RES).data;

		//update skulpt
		gpuSkulpt.loadFromImageData(terrainImageData, options.terrainHeight, options.terrainMidGreyIsLowest);
	}

	var $imageCanvasElem, imageCanvasElemContext;
	var $scaledImageObj, $origImageObj;
	function prepareTerrainImageElements()
	{
		//create canvas that is same size as terrain res so that one vertex maps to one resized pixel
		$imageCanvasElem = $(document.createElement('canvas'));
		$imageCanvasElem[0].id = 'terrainImageCanvas';
		$imageCanvasElem[0].width = TERRAIN_RES;
		$imageCanvasElem[0].height = TERRAIN_RES;
		$imageCanvasElem.css({'position':'fixed', 'top':'55px', 'left':0});
		$('body').append($imageCanvasElem);

		//get canvas context
        imageCanvasElemContext = $imageCanvasElem[0].getContext('2d');

		//load terrain image
		$scaledImageObj = $(new Image());
		$scaledImageObj[0].id = 'scaledTerrainImage';
		$scaledImageObj[0].onload = function()
		{
			//this function is triggered from $origImageObj setting this src

			//start filtering and changing heights
			filterTerrainImageAndGenerateHeight();
		};
		$scaledImageObj.css({'display':'none'});
		$('body').append($scaledImageObj);

		//load original terrain image, scale it using canvas, then set scaled image to $scaledImageObj
		$origImageObj = $(new Image());
		$origImageObj[0].onload = function()
		{
			//copy to scaled canvas to scale this image
			imageCanvasElemContext.drawImage($origImageObj[0], 0, 0, TERRAIN_RES, TERRAIN_RES);

			//get scaled data from canvas and set data for scaledImageObj
			$scaledImageObj[0].src = $imageCanvasElem[0].toDataURL();
		};
	}

	function loadTerrainImage(image)
	{
		console.log('Loading terrain image: ' + image);
		$origImageObj[0].src = image;
	}

	function sculptClearSculpts()
	{
		// gpuSkulpt.getMesh('terrainMesh').clearCurrLayer();
		gpuSkulpt.clear();
	}

	var skarf;
	function setupAr()
	{
		//create a SkArF framework
		if (ARLIB === 'jsartoolkit') {
		    skarf = new SkArF({

                arLibType: 'jsartoolkit',
                trackingElem: source,
                markerSize: 1,  //this is an overall scale, just set to 1 for now
                //NOTE: not using verticalFov for now because the JSARToolKit default projection matrix seems to work better
                //verticalFov: CAM_VERTICAL_FOV,  //must be the same as the render cam
                threshold: options.arTrackingThreshold,
                debug: false,

                canvasContainerElem: $canvasContainerElem,

                rendererType: 'threejs',
                renderer: renderer,
                scene: scene,
                camera: camera,

                markersJsonFile: JSARTOOLKIT_MARKERS_JSON

            });
		} else if (ARLIB === 'jsaruco') {
		    skarf = new SkArF({

                arLibType: 'jsaruco',
                trackingElem: source,
                markerSize: 1,  //this is an overall scale, just set to 1 for now
                verticalFov: CAM_VERTICAL_FOV,  //must be the same as the render cam
                debug: false,

                canvasContainerElem: $canvasContainerElem,

                rendererType: 'threejs',
                renderer: renderer,
                scene: scene,
                camera: camera,

                markersJsonFile: JSARUCO_MARKERS_JSON

            });
		} else {
		    throw new Error('ARLIB type not recognised: ' + ARLIB);
		}

		//Create callback that will call gpuSkulpt.update after clearing renderer but before rendering the main scene
		skarf.addCallback('render', function () {
		    gpuSkulpt.update();
		});
	}

	var $threejsCanvasElem;
	function setupEvents()
	{
		window.addEventListener('resize', window_onResize, false);
		window.addEventListener('keyup', window_onKeyUp, false);

		//attach events to the canvas so that we can get the relative mouse coordinates inside it
		$threejsCanvasElem = $('#threejs-canvas');
		$threejsCanvasElem[0].addEventListener('mousedown', window_onMouseDown, false);
		$threejsCanvasElem[0].addEventListener('mousemove', window_onMouseMove, false);
		$threejsCanvasElem[0].addEventListener('mouseup', window_onMouseUp, false);
	}

	function window_onResize(event)
	{
	    var targetWidth = window.innerWidth;
	    var targetHeight = window.innerHeight;
	    var width, height;

	    //calculate width and height that maintains video aspect ratio
	    var videoAspect = video.width / video.height;
	    var windowAspect = targetWidth / targetHeight;
	    if (windowAspect > videoAspect)
	    {
	        width = targetHeight * 4 / 3;
	        height = targetHeight - 5;
	    }
	    else
	    {
	        width = targetWidth;
	        height = (targetWidth * 3 / 4) - 5;
	    }

		//update renderer size
		skarf.renderer.renderer.setSize(width, height);

		//centralize
		$threejsContainerElem.css({
		    'width': (width*1.25)+'px',
		    'margin': '0 auto'
		});
	}

	function window_onKeyUp(event)
	{
		if (event.keyCode === 16 || event.keyCode === 17)  //shift or ctrl
		{
			//hide cursor when shift or ctrl key is up
			gpuSkulpt.hideCursor();
		}
		if (event.keyCode === 66)
		{
		    createPhysijsCube();
		}
	}

	function createPhysijsCube()
	{
	    var boxFriction = 0.8;
		var boxRestitution = 0.2;
		var width = 0.3;
		var widthSegments = 20;
	    var cubeGeom = new THREE.CubeGeometry(width, width, width, widthSegments, widthSegments, widthSegments);
		var cubeMaterial = Physijs.createMaterial(
			new THREE.MeshPhongMaterial(),
			boxFriction,
			boxRestitution
		);
		materials.push(cubeMaterial);
		var cubeDynMesh = new Physijs.BoxMesh(cubeGeom, cubeMaterial);
        cubeDynMesh.position.x = 1.0;
        cubeDynMesh.position.y = 2.0;
        cubeDynMesh.position.z = 1.0;
        scene.add(cubeDynMesh);
	}

	var isSculpting = false;
	var sculptUvPos = new THREE.Vector2();
	function window_onMouseDown(event)
	{
		if (event.ctrlKey)
		{
			//detect intersection and show cursor
			detectIntersectionAndShowSculptCursor();
            if (intersectPoint)
            {
                //do actual sculpting if clicked
                if (event.button === 0)  //LMB
                {
                    isSculpting = true;
                    sculptTerrain(GpuSkulpt.ADD, intersectPoint, options.sculptAmount);
                }
                else if (event.button === 2)  //RMB
                {
                    isSculpting = true;
                    sculptTerrain(GpuSkulpt.REMOVE, intersectPoint, options.sculptAmount);
                }
            }
		}
		else if (event.shiftKey)
		{
			//detect intersection and show cursor
			detectIntersectionAndShowSculptCursor();
            if (intersectPoint)
            {
                //do actual sculpting if clicked
                if (event.button === 0)  //LMB
                {
                    // isSculpting = true;
                    // sculptTerrain('flatten');
                }
            }
		}
		else if (event.altKey)
		{
		    //do nothing for now
		    //this is just to prevent confirming of objects onto the terrain when rotating the camera
		}
		else
		{
		    if (isAddingObject)
		    {
		        objectsAddObjectConfirm();
		        isAddingObject = false;
		    }
		    else if (isRemovingObject)
		    {
		        objectsRemoveObjectConfirm();
		        isRemovingObject = false;
		    }
		}
	}

	function window_onMouseMove(event)
	{
		event.preventDefault();

		if (event.ctrlKey)
		{
			//detect intersection and show cursor
			detectIntersectionAndShowSculptCursor();
			if (intersectPoint && isSculpting)
			{
                if (event.button === 0)  //LMB
                {
                    sculptTerrain(GpuSkulpt.ADD, intersectPoint, options.sculptAmount);
                }
                else if (event.button === 2)  //RMB
                {
                    sculptTerrain(GpuSkulpt.REMOVE, intersectPoint, options.sculptAmount);
                }
            }
		}
		else if (event.shiftKey)
		{
			//detect intersection and show cursor
			detectIntersectionAndShowSculptCursor();
			if (intersectPoint && isSculpting)
			{
                if (event.button === 0)  //LMB
                {
                    // sculptTerrain('flatten');
                }
            }
		}
		else
		{
		    if (isAddingObject)
		    {
		        intersectPoint = detectIntersection();
                if (intersectPoint)
                {
                    objectsMoveObjectProject(currTransform, intersectPoint);
                }
		    }
		    else if (isRemovingObject)
		    {
		        intersectPoint = detectIntersection();
                if (intersectPoint)
                {
                    objectsRemoveObjectFind(intersectPoint);
                }
		    }
		}
	}

	function window_onMouseUp(event)
	{
		isSculpting = false;
	}

	var worldPos = new THREE.Vector3();
	var camPos = new THREE.Vector3();
	var projector = new THREE.Projector();
	var raycaster = new THREE.Raycaster();
	var intersectPoint = new THREE.Vector3();
	var mousePosNorm = new THREE.Vector2();
	function detectIntersection()
	{
	    //get normalized [-1, 1] mouse position
		mousePosNorm.x = (event.clientX / $threejsCanvasElem.width()) * 2 - 1;
		mousePosNorm.y = -(event.clientY / $threejsCanvasElem.height()) * 2 + 1;

		//unproject 2d point to get 3d point
		worldPos.set(mousePosNorm.x, mousePosNorm.y, 1);
		projector.unprojectVector(worldPos, camera);

		//get camera position
		// var camPos = camera.position;
		camPos.getPositionFromMatrix(camera.matrixWorld);

		//do raycasting
		raycaster.set(camPos, worldPos.sub(camPos).normalize());
		var intersectInfo = raycaster.intersectObject(groundPlaneMesh);

		//get intersection point
		if (intersectInfo && intersectInfo[0])
		{
			return intersectInfo[0].point;
		}
		else
		{
			return null;
		}
	}

	function detectIntersectionAndShowSculptCursor()
	{
		//detect intersection and show cursor
		intersectPoint = detectIntersection();
		if (intersectPoint)
		{
			//show cursor at intersection point
			gpuSkulpt.updateCursor(intersectPoint);
			gpuSkulpt.showCursor();
		}
		else
		{
			//cursor is out of terrain, so hide it, otherwise it will remain at the edge
			gpuSkulpt.hideCursor();
		}
	}

	function sculptTerrain(type, position, amount)
	{
	    //sculpt the gpu terrain
	    gpuSkulpt.sculpt(type, position, amount);

	    //update the proxy geometry
	    var pixelData = gpuSkulpt.getPixelData();
	    pixelData = resizeAndFlipData(pixelData);
	    updateProxyTerrain(pixelData);

	    //update Physijs heightfield mesh
	    //NOTE: have to recreate a new Physijs.HeightfieldMesh every time we change the vertex positions
	    scene.remove(proxyTerrainMesh);  //TODO: check if there is a need to delete the mesh to free the memory
	    createPhysijsHeightfieldMesh();
	}

	function resizeAndFlipData(pixelData)
	{
	    //draw pixelData to full-size canvas first
	    drawDataToCanvas(pixelData, $sculptedTerrainTextureCanvasElem[0]);

	    //draw pixelData to a scaled and vertically-flipped canvas
        proxyTerrainTextureContext.drawImage($sculptedTerrainTextureCanvasElem[0], 0, 0, PROXY_TERRAIN_RES, -PROXY_TERRAIN_RES);

	    //get data from the scaled canvas
	    return proxyTerrainTextureContext.getImageData(0, 0, PROXY_TERRAIN_RES, PROXY_TERRAIN_RES).data;
	}

	function drawDataToCanvas(pixelData, canvas)
	{
        var context = canvas.getContext('2d');
        imageData = context.getImageData(0, 0, canvas.width, canvas.height);  //assume that image data has already been created

        var i, len;
        for (i = 0, len = imageData.data.length; i < len; i += 4)
        {
            imageData.data[i + 0] = pixelData[i + 0];
            imageData.data[i + 1] = pixelData[i + 1];
            imageData.data[i + 2] = pixelData[i + 2];
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
    };

	function updateProxyTerrain(pixelData)
	{
	    var v = proxyTerrainGeom.vertices;
	    var i, len;
	    for (i = 0, len = v.length; i < len; i++)
	    {
	        v[i].z = pixelData[4 * i] / 255.0;
	    }
	    proxyTerrainGeom.verticesNeedUpdate = true;
	    proxyTerrainGeom.computeFaceNormals();
	    proxyTerrainGeom.computeVertexNormals();
	    proxyTerrainGeom.normalsNeedUpdate = true;
	}

	var renderStats, physijsStats, glStats;
	function setupStats()
	{
		//create a stats monitor for rendering
		renderStats = new Stats();
		$('body').append(renderStats.domElement);

		//create a stats monitor for Physijs
		physijsStats = new Stats();
		$('body').append(physijsStats.domElement);
		physijsStats.domElement.style.position = 'absolute';
		physijsStats.domElement.style.left = '0px';
		physijsStats.domElement.style.top = '50px';

		//create a stats monitor for more details
		glStats = new THREEx.RendererStats();
		$('body').append(glStats.domElement);
		glStats.domElement.style.position = 'absolute';
		glStats.domElement.style.left = '0px';
		glStats.domElement.style.top = '100px';
	}

    var gui;
    var arFolder, terrainFolder, sculptFolder, objectsFolder, renderingFolder, displayFolder, debugFolder;
    var terrainPreBlurControl, terrainHeightControl
    var changeTerrainImage, toggleDebugTerrainImage, toggleTerrainMidGreyIsLowest, changeTerrainPreBlur, changeTerrainHeight
    var sculptSizeControl, sculptAmountControl, toggleSculptTexture;
    var changeSculptSize, changeSculptAmount;
    var toggleWireframe, toggleLocalAxis, toggleOriginPlane;
	function setupGui() {

		gui = new dat.GUI({width: 300});
		// gui.close();  //close GUI by default

		var control;

		//Tracking folder
		arFolder = gui.addFolder('Augmented Reality');
		arFolder.open();

		control = arFolder.add(options, 'arOn').name('On').listen();

		if (ARLIB === 'jsartoolkit') {
            control = arFolder.add(options, 'arTrackingThreshold', 0, 255).name('Tracking Threshold');
            changeTrackingThreshold = function (value)
            {
                skarf.arLib.threshold = value;
            }
            control.onChange(changeTrackingThreshold);
        }

		//Terrain folder
		terrainFolder = gui.addFolder('Terrain');
		terrainFolder.open();

		var control = terrainFolder.add(options, 'terrainImage', terrainImages).name('Image').listen();
		changeTerrainImage = function(value)
		{
			loadTerrainImage(value);
			options.terrainImage = value;

			//load some presets so that the loaded terrain looks nicer
			options.terrainPreBlur = terrainImageSettings[value].preblur;
			options.terrainHeight = terrainImageSettings[value].height;
			options.terrainMidGreyIsLowest = terrainImageSettings[value].midGreyIsLowest;

			//update display
			for (var i in terrainFolder.__controllers) {
				terrainFolder.__controllers[i].updateDisplay();
			}
		}
		control.onChange(changeTerrainImage);
		//changeTerrainImage('/resources/images/clouds_256.png');

		control = terrainFolder.add(options, 'terrainMidGreyIsLowest').name('Mid Grey Lowest').listen();
		toggleTerrainMidGreyIsLowest = function(value)
		{
			gpuSkulpt.loadFromImageData(terrainImageData, options.terrainHeight, options.terrainMidGreyIsLowest);
			options.terrainMidGreyIsLowest = value;
		}
		control.onChange(toggleTerrainMidGreyIsLowest);
		//toggleTerrainMidGreyIsLowest(options.terrainMidGreyIsLowest);

		terrainPreBlurControl = terrainFolder.add(options, 'terrainPreBlur', 0, 10).name('Pre-Blur').listen();
		changeTerrainPreBlur = function(value)
		{
		    value = THREE.Math.clamp(value, terrainPreBlurControl.__min, terrainPreBlurControl.__max);
			filterTerrainImageAndGenerateHeight(value);
			options.terrainPreBlur = value;
		}
		terrainPreBlurControl.onChange(changeTerrainPreBlur);
		//changeTerrainPreBlur(options.terrainPreBlur);

		terrainHeightControl = terrainFolder.add(options, 'terrainHeight', 0, 4).name('Height').listen();
		changeTerrainHeight = function(value)
		{
		    value = THREE.Math.clamp(value, terrainHeightControl.__min, terrainHeightControl.__max);
			gpuSkulpt.loadFromImageData(terrainImageData, options.terrainHeight, options.terrainMidGreyIsLowest);
			options.terrainHeight = value;
		}
		terrainHeightControl.onChange(changeTerrainHeight);
		//changeTerrainHeight(options.terrainHeight);

		//Sculpt folder
		sculptFolder = gui.addFolder('Sculpt');
		sculptFolder.open();

		sculptSizeControl = sculptFolder.add(options, 'sculptSize', 0.1, 10.0).name('Size').listen();
		changeSculptSize = function (value)
		{
		    value = THREE.Math.clamp(value, sculptSizeControl.__min, sculptSizeControl.__max);
			gpuSkulpt.setBrushSize(value);
			options.sculptSize = value;
		}
		sculptSizeControl.onChange(changeSculptSize);
		changeSculptSize(options.sculptSize);

		sculptAmountControl = sculptFolder.add(options, 'sculptAmount', 0.01, 1.0).name('Amount');
		changeSculptAmount = function (value)
		{
			value = THREE.Math.clamp(value, sculptAmountControl.__min, sculptAmountControl.__max);
			gpuSkulpt.setBrushAmount(value);
			options.sculptAmount = value;
		}
		sculptAmountControl.onChange(changeSculptAmount);
		changeSculptAmount(options.sculptAmount);

		control = sculptFolder.add(options, 'sculptClearSculpts').name('Clear Sculpts');

		//Objects folder
		objectsFolder = gui.addFolder('Objects');
		objectsFolder.open();

		control = objectsFolder.add(options, 'objectsObject', objects).name('Object');

		control = objectsFolder.add(options, 'objectsAddObject').name('Add From Selection');

		control = objectsFolder.add(options, 'objectsRemoveObject').name('Remove');

		//Display folder
		displayFolder = gui.addFolder('Display');
		displayFolder.open();

		control = displayFolder.add(options, 'displayWireframe').name('Wireframe').listen();
		toggleWireframe = function (value)
		{
			skarf.renderer.setWireframeVisible(value);
			var i, len;
			for (i = 0, len = materials.length; i < len; i++)
			{
			    materials[i].wireframe = value;
			}
			options.displayWireframe = value;
			gpuSkulpt.displayWireframe = value;
		}
		control.onChange(toggleWireframe);
		toggleWireframe(options.displayWireframe);

		control = displayFolder.add(options, 'displayLocalAxis').name('Local Axis').listen();
		toggleLocalAxis = function (value)
		{
			skarf.renderer.setLocalAxisVisible(value);
			options.displayLocalAxis = value;
		}
		control.onChange(toggleLocalAxis);
		toggleLocalAxis(options.displayLocalAxis);

		//Debug folder
		debugFolder = gui.addFolder('Debug View');
		debugFolder.open();

		control = debugFolder.add(options, 'debugTrackingInfo').name('Tracking Info');
		toggleDebugTrackingInfo = function (value)
		{
			skarf.arLib.debug = value;
		}
		control.onChange(toggleDebugTrackingInfo);
		toggleDebugTrackingInfo(options.debugTrackingInfo);

		control = debugFolder.add(options, 'debugTerrainImage').name('Terrain Image').listen();
		toggleDebugTerrainImage = function(value)
		{
			if (value)
			{
				$imageCanvasElem.css({'display':'block'});
			}
			else
			{
				$imageCanvasElem.css({'display':'none'});
			}
			options.debugTerrainImage = value;
		}
		control.onChange(toggleDebugTerrainImage);
		toggleDebugTerrainImage(options.debugTerrainImage);

		control = debugFolder.add(options, 'debugSculptTexture').name('Sculpt Texture').listen();
		toggleSculptTexture = function(value)
		{
            visMesh.visible = value;
            options.debugSculptTexture = value;
		}
		control.onChange(toggleSculptTexture);
		toggleSculptTexture(options.debugSculptTexture);
	}

	function setupGuiMarkerCallbacks() {

	    //NOTE: not allowing changing of any options under the Tracking GUI folder using AR markers, because it just does not make sense

	    //test timer
	    testTimer_reached = function (params) {
	        alert('Time is up!');
	    };

	    //terrain
	    terrainImageComboBox_changed = function (params) {
	        changeTerrainImage(terrainImages[Object.keys(terrainImages)[params.selectedId]]);
	    };
	    terrainShowImageCheckbox_toggled = function (params) {
            toggleDebugTerrainImage(params.checked);
        };
        terrainMidGreyLowestCheckbox_toggled = function (params) {
            toggleTerrainMidGreyIsLowest(params.checked);
        };
        terrainPreBlurImageSlider_changed = function (params) {
            changeTerrainPreBlur(options.terrainPreBlur + params.delta);
        };
        terrainImageHeightSlider_changed = function (params) {
            changeTerrainHeight(options.terrainHeight + params.delta);
        };

	    //sculpt
	    sculptSizeSlider_changed = function (params) {
            changeSculptSize(options.sculptSize + params.delta);
        };
        sculptAmountSlider_changed = function (params) {
            changeSculptAmount(options.sculptAmount + params.delta);
        };
        sculptClearButton_clicked = function (params) {
            sculptClearSculpts();
        };
        sculptShowSimTextureCheckbox_toggled = function (params) {
            toggleSculptTexture(params.checked);
        };
        sculptAddGeneric_moved = function (params) {
            gpuSkulpt.updateCursor(params.position);
            gpuSkulpt.showCursor();
            gpuSkulpt.sculpt(GpuSkulpt.ADD, params.position, options.sculptAmount);
        }
        sculptAddGeneric_hidden = function (params) {
            gpuSkulpt.hideCursor();
        }
        sculptRemoveGeneric_moved = function (params) {
            gpuSkulpt.updateCursor(params.position);
            gpuSkulpt.showCursor();
            gpuSkulpt.sculpt(GpuSkulpt.REMOVE, params.position, options.sculptAmount);
        }
        sculptRemoveGeneric_hidden = function (params) {
            gpuSkulpt.hideCursor();
        }

        //display
        displayWireframeCheckbox_toggled = function (params) {
            toggleWireframe(params.checked);
        };
        displayLocalAxisCheckbox_toggled = function (params) {
            toggleLocalAxis(params.checked);
        };
        displayOriginPlaneCheckbox_toggled = function (params) {
            toggleOriginPlane(params.checked);
        };
    }

    var isAddingObject = false;
    var objectTransforms = [];
    var currTransform = null;
    function objectsAddObject()
    {
        objectMarkerId = options.objectsObject;

        //create an Object3D in the scene first
        currTransform = new THREE.Object3D();
        objectTransforms.push(currTransform);
        scene.add(currTransform);

        //load the object to the transform
        markerManager.loadForMarker(objectMarkerId, currTransform, 1, options.displayWireframe);

        //turn on flag for object to follow mouse detected intersection point
        isAddingObject = true;
    }

    function objectsMoveObjectProject(transform, position)
    {
        transform.position.copy(position);

        //read in terrain height and shift up in Y
        var pixelData = gpuSkulpt.getPixelData();
        var index = getPixelIndex(position);
        transform.position.y = pixelData[4 * index + 0] / 255.0;  //just read the red channel
    }

    function getPixelIndex(position)
    {
        var row = Math.floor((-position.z + terrainHalfSize) / TERRAIN_SIZE * TERRAIN_RES);
        var col = Math.floor((position.x + terrainHalfSize) / TERRAIN_SIZE * TERRAIN_RES);
        return (row * TERRAIN_RES) + col;
    }

    function objectsAddObjectConfirm()
    {
        isAddingObject = false;
    }

    var isRemovingObject = false;
    function objectsRemoveObject()
    {
        //turn on flag for selection with mouse
        isRemovingObject = true;
    }

    var objectTransformToRemove = null
    var highlightEmissive = new THREE.Color('#0000ff');
    var normalEmissive = new THREE.Color('#000000');
    function objectsRemoveObjectFind(position)
    {
        objectTransformToRemove = null;

        //search through all objects
        var i, len, transform, mesh;
        for (i = 0, len = objectTransforms.length; i < len; i++)
        {
            transform = objectTransforms[i];
            mesh = transform.children[0];  //assume that there is one and only one child
            var transformedBBox = mesh.geometry.boundingBox.clone().applyMatrix4(mesh.matrixWorld);
            if (!objectTransformToRemove && position.x >= transformedBBox.min.x && position.x <= transformedBBox.max.x && position.z >= transformedBBox.min.z && position.z <= transformedBBox.max.z)
            {
                //highlight the object
                highlightMesh(mesh, highlightEmissive);

                //store object to remove
                objectTransformToRemove = transform;
            }
            else
            {
                //remove highlight on the object
                highlightMesh(mesh, normalEmissive);
            }
        }
    }

    function highlightMesh(mesh, color)
    {
        var material = mesh.material;
        if (material instanceof THREE.MeshFaceMaterial)
        {
            var i, len;
            for (i = 0, len = material.materials.length; i < len; i++)
            {
                material.materials[i].emissive.copy(color);
            }
        }
        else
        {
            material.emissive.copy(color);
        }
    }

    function objectsRemoveObjectConfirm()
    {
        if (objectTransformToRemove)
        {
            //remove object transform
            //TODO: check if there is a need to delete the mesh to free the memory
            scene.remove(objectTransformToRemove);

            //remove from array
            var i, len;
            for (i = 0, len = objectTransforms.length; i < len; i++)
            {
                if (objectTransforms[i] === objectTransformToRemove)
                {
                    objectTransforms.splice(i, 1);
                }
            }
        }

        //turn off flag
        isRemovingObject = false;
    }

	var $canvasContainerElem, $threejsContainerElem;
	var arJustOn = true;
	var arJustOff = true;
	$(document).ready(function()
	{
		//check for WebGL
		checkWebGl();

		console.log('Document is ready.');

		$threejsContainerElem = $('#threejs-container');
		$canvasContainerElem = $('#canvas-container');

		//stream to video element
		setupVideo();

		//setup main scene
		setupMainScene();

		//setup Skulpt
		setupSkulpt()

		//setup terrain image
		prepareTerrainImageElements();
        loadTerrainImage(options.terrainImage);

		//setup AR
		setupAr();

		//setup events
		setupEvents();

		//setup stats monitor
		setupStats();

		//setup GUI marker callbacks
		setupGuiMarkerCallbacks();

		//setup GUI
		setupGui();

		//start Physijs sim
		scene.simulate();

		//main loop
		function loop()
		{
			var dt = clock.getDelta();  //have to call this before getElapsedTime()
			var time = clock.getElapsedTime();

			visMaterial.map = gpuSkulpt.rttCombinedLayer;

			if (options.arOn) {

			    //if user is using AR:

			    if (arJustOn) {

			        //stream webcam video
			        streamVideo(video);

			        //init skarf camera again and do not allow user to control the camera
			        skarf.initCameraProjMatrix();
			        camera.matrixAutoUpdate = false;
			    }

			    //get skarf to update (this has callbacks to call update for gpuSkulpt etc too)
			    skarf.update(dt);

			    arJustOn = false;
                arJustOff = true;

			} else {

			    //otherwise, have to do manual updates as per normal

			    if (arJustOff) {

			        //TODO: turn off video streaming

			        //update cam projection matrix
                    camera.updateProjectionMatrix();
                    camera.matrixAutoUpdate = true;
                }

                //take back control of camera
                controls.update();

			    //render
                renderer.autoClear = false;
                renderer.clear();
                gpuSkulpt.update();
                renderer.render(scene, camera);

                arJustOn = true;
                arJustOff = false;
			}

			renderStats.update();
			glStats.update(renderer);

			requestAnimationFrame(loop);
		}
		loop();

	});
	</script>
</head>
<body style='background-color: #081419'>
    <div class="invisible" id="video-container">
		<div class="caption">&lt;video&gt;</div>
		<video id="mainVideo" width="640" height="480" autoplay="autoplay" muted="true"></video>
	</div>
	<div class="invisible" id="canvas-container">
		<div class="caption">&lt;canvas&gt;</div>
	</div>
	<div class="invisible" id="debugCanvas-container">
		<div class="caption">debug &lt;canvas&gt;</div>
		<canvas id="debugCanvas" width="640" height="480"></canvas>
	</div>
	<div id="threejs-container"></div>
	<div class="invisible" id="sculptedTerrainTextureCanvas-container"></div>
</body>
</html>